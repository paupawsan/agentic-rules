<!DOCTYPE html>
<!-- Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agentic Rules Framework Setup</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #333;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      padding: 40px 30px 30px 30px;
      text-align: center;
      position: relative;
      min-height: 120px;
      display: flex;
      flex-direction: column;
    }

    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .language-selector {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 6px 12px;
      font-size: 13px;
      color: white;
      z-index: 10;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .language-selector select {
      background: transparent;
      border: none;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      outline: none;
      min-width: 120px;
    }

    .language-selector select option {
      background: #2c3e50;
      color: white;
    }

    .language-selector::before {
      content: 'ğŸŒ';
      font-size: 16px;
      opacity: 0.9;
    }

    .header-content {
      padding-top: 10px;
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      font-weight: 300;
      margin-top: 0;
    }

    .header p {
      font-size: 1.2em;
      opacity: 0.9;
      margin-bottom: 0;
      line-height: 1.4;
    }

    .content {
      padding: 40px;
    }

    .section {
      margin-bottom: 40px;
      padding: 25px;
      border: 2px solid #f0f0f0;
      border-radius: 8px;
      background: #fafafa;
    }

    .section h2 {
      color: #2c3e50;
      margin-bottom: 20px;
      font-size: 1.5em;
      border-bottom: 3px solid #3498db;
      padding-bottom: 10px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #34495e;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 16px;
      transition: border-color 0.3s;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .checkbox-group input[type="checkbox"] {
      width: auto;
      margin: 0;
    }

    .rule-card {
      border: 2px solid #e1e8ed;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 15px;
      background: white;
      transition: all 0.3s;
    }

    .rule-card:hover {
      border-color: #3498db;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .rule-card h3 {
      color: #2c3e50;
      margin-bottom: 10px;
      font-size: 1.3em;
    }

    .rule-card p {
      color: #7f8c8d;
      margin-bottom: 15px;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
    }

    .loading-spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .rule-toggle {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .rule-toggle input[type="checkbox"] {
      width: 20px;
      height: 20px;
    }

    .btn {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      display: inline-block;
      text-decoration: none;
      text-align: center;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }

    .btn:disabled {
      background: #bdc3c7;
      cursor: not-allowed;
      transform: none;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #ecf0f1;
      border-radius: 4px;
      margin: 20px 0;
      overflow: hidden;
      display: none;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4facfe, #00f2fe);
      width: 0%;
      transition: width 0.3s ease;
    }

    .result {
      margin-top: 20px;
      padding: 20px;
      border-radius: 8px;
      display: none;
    }

    .result.success {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
    }

    .result.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
    }

    .file-list {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 15px;
      margin-top: 10px;
    }

    .file-list pre {
      margin: 0;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }

    .help-text {
      font-size: 14px;
      color: #6c757d;
      margin-top: 5px;
    }

    .required {
      color: #e74c3c;
      font-weight: bold;
    }

    .tab-container {
      margin-bottom: 30px;
    }

    .tab-buttons {
      display: flex;
      margin-bottom: 20px;
    }

    .tab-btn {
      padding: 12px 24px;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      cursor: pointer;
      font-size: 16px;
      border-radius: 6px 6px 0 0;
      margin-right: 5px;
      transition: all 0.3s;
    }

    .tab-btn.active {
      background: white;
      border-bottom: 3px solid #3498db;
      margin-bottom: -1px;
    }

    .tab-content {
      display: none;
      padding: 20px;
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 0 6px 6px 6px;
    }

    .tab-content.active {
      display: block;
    }

    @media (max-width: 768px) {
      .container {
        margin: 10px;
      }

      .header {
        padding: 60px 20px 25px 20px;
        min-height: 140px;
      }

      .header h1 {
        font-size: 2em;
        margin-bottom: 15px;
      }

      .header p {
        margin-bottom: 20px;
      }

      .language-selector {
        position: absolute;
        top: 15px;
        right: 20px;
        padding: 5px 10px;
        font-size: 12px;
        border-radius: 15px;
      }

      .language-selector select {
        min-width: 100px;
        font-size: 12px;
      }

      .content {
        padding: 20px;
      }

      .tab-buttons {
        flex-direction: column;
      }

      .tab-btn {
        margin-right: 0;
        margin-bottom: 5px;
        border-radius: 6px;
      }
    }

    @media (max-width: 480px) {
      .header {
        padding: 50px 15px 20px 15px;
        text-align: left;
      }

      .header-content {
        padding-top: 5px;
      }

      .header h1 {
        font-size: 1.8em;
        margin-bottom: 10px;
      }

      .language-selector {
        position: static;
        margin-top: 15px;
        margin-bottom: 10px;
        justify-content: center;
        width: 100%;
        max-width: 200px;
        margin-left: auto;
        margin-right: auto;
      }
    }
  </style>
  <!-- AUTO GENERATED CONTENT START -->
  <!-- This section is automatically updated by update_localization.py and generate_simple_setup.py -->
  <!-- Sources: localization.json and setup.json files with RULES.md templates -->
  <script>
    // ---AUTO GENERATED STATICWEBCONFIG START---
  const staticWebConfig = {
  "version": "0.1.0",
  "description": "Static web configuration generated from setup.json files",
  "availableLanguages": [
    "en",
    "id",
    "ja"
  ],
  "uiLanguage": "en",
  "agentLanguage": "en",
  "plugins": {
    "modules/critical-thinking-rules": {
      "name": "modules/critical-thinking-rules",
      "display_name": "Critical Thinking Rules",
      "description": "Intellectual rigor and hallucination prevention",
      "localization": {
        "en": {
          "plugin_name": "Critical Thinking Rules",
          "description": "Intellectual rigor and hallucination prevention"
        },
        "ja": {
          "plugin_name": "æ‰¹åˆ¤çš„æ€è€ƒãƒ«ãƒ¼ãƒ«",
          "description": "çŸ¥çš„å³å¯†ã•ã¨å¹»è¦šé˜²æ­¢"
        },
        "id": {
          "plugin_name": "Aturan Berpikir Kritis",
          "description": "Keketatan intelektual dan pencegahan halusinasi"
        }
      },
      "mandatory_config": [],
      "optional_config": [
        {
          "name": "verification_levels",
          "type": "choice",
          "localization": {
            "en": {
              "title": "Verification Levels",
              "description": "Configure how thoroughly to verify information"
            },
            "ja": {
              "title": "æ¤œè¨¼ãƒ¬ãƒ™ãƒ«",
              "description": "æƒ…å ±ã®æ¤œè¨¼ã®å¾¹åº•åº¦ã‚’è¨­å®š"
            },
            "id": {
              "title": "Tingkat Verifikasi",
              "description": "Konfigurasikan seberapa menyeluruh verifikasi informasi"
            }
          },
          "options": [
            {
              "name": "balanced_verification",
              "localization": {
                "en": {
                  "description": "Verify factual claims with reasonable rigor"
                },
                "ja": {
                  "description": "åˆç†çš„ãªå³å¯†ã•ã§äº‹å®Ÿçš„ä¸»å¼µã‚’æ¤œè¨¼"
                },
                "id": {
                  "description": "Verifikasi klaim faktual dengan ketelitian yang wajar"
                }
              },
              "recommended": true,
              "settings": {
                "verification.factual_claim_verification": true,
                "verification.min_sources_required": 2
              }
            }
          ]
        },
        {
          "name": "error_handling",
          "type": "choice",
          "localization": {
            "en": {
              "title": "Error Handling",
              "description": "Configure error admission and correction behavior"
            },
            "ja": {
              "title": "ã‚¨ãƒ©ãƒ¼å‡¦ç†",
              "description": "ã‚¨ãƒ©ãƒ¼æ‰¿èªã¨ä¿®æ­£ã®å‹•ä½œã‚’è¨­å®š"
            },
            "id": {
              "title": "Penanganan Error",
              "description": "Konfigurasikan perilaku pengakuan dan koreksi error"
            }
          },
          "options": [
            {
              "name": "transparent_error_handling",
              "localization": {
                "en": {
                  "description": "Immediately admit errors and log corrections"
                },
                "ja": {
                  "description": "ã™ãã«ã‚¨ãƒ©ãƒ¼ã‚’æ‰¿èªã—ä¿®æ­£ã‚’ãƒ­ã‚°"
                },
                "id": {
                  "description": "Segera akui error dan log koreksi"
                }
              },
              "recommended": true,
              "settings": {
                "error_handling.immediate_error_admission": true,
                "error_handling.log_corrections": true
              }
            }
          ]
        }
      ],
      "default_settings": {
        "critical_thinking_rules": {
          "enabled": false,
          "verification_level": "standard",
          "error_admission": {
            "enabled": true,
            "immediate_correction": true,
            "transparency_logging": true
          },
          "assumption_challenge": {
            "enabled": true,
            "challenge_threshold": "medium",
            "automatic_detection": true
          },
          "ground_check": {
            "enabled": true,
            "required_confirmations": 2,
            "verification_timeout_seconds": 30,
            "fallback_to_uncertainty": true
          },
          "hallucination_prevention": {
            "enabled": true,
            "reality_checks": true,
            "conservative_estimation": true,
            "uncertainty_qualification": true
          },
          "verification_categories": {
            "factual": {
              "min_sources": 3,
              "require_independent": true
            },
            "technical": {
              "require_testing": true,
              "allow_simulation": true
            },
            "logical": {
              "check_consistency": true,
              "identify_fallacies": true
            }
          },
          "confidence_calibration": {
            "enabled": true,
            "track_accuracy": true,
            "adjust_thresholds": true
          },
          "response_formats": {
            "balanced_analysis": true,
            "error_correction": true,
            "assumption_challenge": true
          }
        }
      },
      "templates": {
        "en": "# Critical Thinking Rules Agent Integration (English)\n\n**âš ï¸ SAFETY PRECAUTION**: This is a TEMPLATE file. Agents MUST NOT auto-load this file. Only load when renamed to `AGENTS.md`, `GEMINI.md`, OR `CLAUDE.md` after explicit user activation AND when `critical_thinking_rules.enabled = true` in settings.json.\n\n**MANDATORY**: If critical_thinking_rules.enabled = true in settings.json, agents MUST implement all algorithms below.\n\n## Critical Thinking Rules Extended Overview\nIntellectual rigor and hallucination prevention\n\n## Required Implementation Algorithms\n\n### Algorithm: CriticalThinkingRulesExtended_Initialization_Process\n**MANDATORY**: Execute when critical_thinking_rules.enabled = true\n\n**Steps**:\n1. Read critical-thinking-rules-extended/settings.json\n2. Initialize critical thinking rules extended system\n3. Validate configuration settings\n4. Return initialized system\n\n**CRITICAL**: Do NOT auto-enable - respect user's enabled setting.\n\n### Algorithm: CriticalThinkingRulesExtended_Main_Process\n**MANDATORY**: Execute for all relevant user interactions when enabled\n\n**Steps**:\n1. Check critical_thinking_rules.enabled = true\n2. Analyze current context and request\n3. Apply critical thinking rules extended algorithms\n4. Process and return results\n\n### Algorithm: CriticalThinkingRulesExtended_Cleanup_Process\n**MANDATORY**: Execute periodically, require user consent\n\n**Steps**:\n1. Check cleanup settings\n2. Identify obsolete data\n3. Request user consent for cleanup\n4. Perform safe cleanup operations\n\n## Configuration Requirements\n- Settings file: `critical-thinking-rules-extended/settings.json`\n- Configuration key: `critical_thinking_rules.enabled`\n- Bootstrap compliance required\n\n## Error Handling\n**MANDATORY**: Agents must handle errors gracefully:\n- Configuration file missing â†’ Skip critical thinking rules extended operations\n- Invalid settings â†’ Use default values and log warnings\n- System errors â†’ Continue operation without critical thinking rules extended features\n\n## Framework Integration\n**MANDATORY**: This framework remains a tool and should never be included in user project codebases. All integrations happen through the rule files in their respective directories.\n\n## Agent Responsibility\nAgents using this framework must:\n- Respect all user settings and configurations\n- Provide clear feedback when critical thinking rules extended is disabled\n- Maintain framework neutrality in generated content\n- Follow bootstrap compliance requirements\n\n**VIOLATION**: Agents that do not respect these integration requirements or user settings.\n\n<!-- METADATA: Critical Thinking Rules Extended agent integration template -->\n<!-- LICENSE: Copyright (c) 2025 {author_name} - Licensed under the MIT License. See LICENSE file for details. -->\n",
        "id": "# Integrasi Agen Critical Thinking Rules Extended (Bahasa Indonesia)\n\n**âš ï¸ PRECAUTION KEAMANAN**: Ini adalah file TEMPLATE. Agen TIDAK BOLEH memuat file ini secara otomatis. Hanya muat ketika diganti nama menjadi `AGENTS.md`, `GEMINI.md`, atau `CLAUDE.md` setelah aktivasi eksplisit pengguna DAN ketika `critical_thinking_rules.enabled = true` dalam settings.json.\n\n**WAJIB**: Jika critical_thinking_rules.enabled = true dalam settings.json, agen HARUS mengimplementasikan semua algoritma di bawah ini.\n\n## Ringkasan Critical Thinking Rules Extended\nIntellectual rigor and hallucination prevention\n\n## Algoritma Implementasi yang Diperlukan\n\n### Algoritma: CriticalThinkingRulesExtended_Initialization_Process\n**WAJIB**: Eksekusi ketika critical_thinking_rules.enabled = true\n\n**Langkah**:\n1. Baca critical-thinking-rules-extended/settings.json\n2. Inisialisasi sistem critical thinking rules extended\n3. Validasi pengaturan konfigurasi\n4. Kembalikan sistem yang diinisialisasi\n\n**KRITIS**: JANGAN aktifkan otomatis - hormati pengaturan aktif pengguna.\n\n### Algoritma: CriticalThinkingRulesExtended_Main_Process\n**WAJIB**: Eksekusi untuk semua interaksi pengguna terkait ketika aktif\n\n**Langkah**:\n1. Periksa critical_thinking_rules.enabled = true\n2. Analisis konteks dan permintaan saat ini\n3. Terapkan algoritma critical thinking rules extended\n4. Proses dan kembalikan hasil\n\n### Algoritma: CriticalThinkingRulesExtended_Cleanup_Process\n**WAJIB**: Eksekusi secara berkala, memerlukan persetujuan pengguna\n\n**Langkah**:\n1. Periksa pengaturan pembersihan\n2. Identifikasi data yang kedaluwarsa\n3. Minta persetujuan pengguna untuk pembersihan\n4. Lakukan pembersihan yang aman\n\n## Persyaratan Konfigurasi\n- File pengaturan: `critical-thinking-rules-extended/settings.json`\n- Kunci konfigurasi: `critical_thinking_rules.enabled`\n- Kepatuhan bootstrap wajib\n\n## Penanganan Error\n**WAJIB**: Agen harus menangani error dengan baik:\n- File konfigurasi hilang â†’ Lewati operasi critical thinking rules extended\n- Pengaturan tidak valid â†’ Gunakan nilai default dan log peringatan\n- Error sistem â†’ Lanjutkan operasi tanpa fitur critical thinking rules extended\n\n## Integrasi Framework\n**WAJIB**: Framework ini tetap menjadi alat dan tidak boleh dimasukkan ke dalam codebase proyek pengguna. Semua integrasi terjadi melalui file aturan di direktori masing-masing.\n\n## Tanggung Jawab Agen\nAgen yang menggunakan framework ini harus:\n- Menghormati semua pengaturan dan konfigurasi pengguna\n- Memberikan umpan balik yang jelas ketika critical thinking rules extended dinonaktifkan\n- Mempertahankan netralitas framework dalam konten yang dihasilkan\n- Mengikuti persyaratan kepatuhan bootstrap\n\n**PELANGGARAN**: Agen yang tidak menghormati persyaratan integrasi ini atau pengaturan pengguna.\n\n<!-- METADATA: template integrasi agen Critical Thinking Rules Extended -->\n<!-- LICENSE: Copyright (c) 2025 {author_name} - Dilisensikan di bawah Lisensi MIT. Lihat file LICENSE untuk detail. -->\n",
        "ja": "# Critical Thinking Rules Extended ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±åˆ (æ—¥æœ¬èª)\n\n**âš ï¸ å®‰å…¨å¯¾ç­–**: ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯TEMPLATEã§ã™ã€‚ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•èª­ã¿è¾¼ã¿ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚`AGENTS.md`ã€`GEMINI.md`ã€ã¾ãŸã¯`CLAUDE.md`ã«åå‰ã‚’å¤‰æ›´ã—ãŸå¾Œã®æ˜ç¤ºçš„ãªãƒ¦ãƒ¼ã‚¶ãƒ¼æœ‰åŠ¹åŒ–æ™‚ã€ãŠã‚ˆã³settings.jsonã§`critical_thinking_rules.enabled = true`ã®å ´åˆã®ã¿èª­ã¿è¾¼ã¿ã¾ã™ã€‚\n\n**å¿…é ˆ**: settings.jsonã§critical_thinking_rules.enabled = trueã®å ´åˆã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ä»¥ä¸‹ã®ã™ã¹ã¦ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n\n## Critical Thinking Rules Extended ã®æ¦‚è¦\nIntellectual rigor and hallucination prevention\n\n## å¿…è¦ãªå®Ÿè£…ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ \n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : CriticalThinkingRulesExtended_Initialization_Process\n**å¿…é ˆ**: critical_thinking_rules.enabled = true ã®å ´åˆã«å®Ÿè¡Œ\n\n**ã‚¹ãƒ†ãƒƒãƒ—**:\n1. critical-thinking-rules-extended/settings.json ã‚’èª­ã¿è¾¼ã‚€\n2. critical thinking rules extended ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–\n3. è¨­å®šã‚’æ¤œè¨¼\n4. åˆæœŸåŒ–ã•ã‚ŒãŸã‚·ã‚¹ãƒ†ãƒ ã‚’è¿”ã™\n\n**é‡è¦**: è‡ªå‹•æœ‰åŠ¹åŒ–ã—ãªã„ - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœ‰åŠ¹è¨­å®šã‚’å°Šé‡ã™ã‚‹ã€‚\n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : CriticalThinkingRulesExtended_Main_Process\n**å¿…é ˆ**: æœ‰åŠ¹æ™‚ã«ã™ã¹ã¦ã®é–¢é€£ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã«å¯¾ã—ã¦å®Ÿè¡Œ\n\n**ã‚¹ãƒ†ãƒƒãƒ—**:\n1. critical_thinking_rules.enabled = true ã‚’ç¢ºèª\n2. ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’åˆ†æ\n3. critical thinking rules extended ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’é©ç”¨\n4. çµæœã‚’å‡¦ç†ã—ã¦è¿”ã™\n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : CriticalThinkingRulesExtended_Cleanup_Process\n**å¿…é ˆ**: å®šæœŸçš„ã«å®Ÿè¡Œã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åŒæ„ã‚’è¦æ±‚\n\n**ã‚¹ãƒ†ãƒƒãƒ—**:\n1. ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—è¨­å®šã‚’ç¢ºèª\n2. å¤ããªã£ãŸãƒ‡ãƒ¼ã‚¿ã‚’ç‰¹å®š\n3. ãƒ¦ãƒ¼ã‚¶ãƒ¼åŒæ„ã‚’è¦æ±‚\n4. å®‰å…¨ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ\n\n## è¨­å®šè¦ä»¶\n- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«: `critical-thinking-rules-extended/settings.json`\n- è¨­å®šã‚­ãƒ¼: `critical_thinking_rules.enabled`\n- Bootstrap æº–æ‹ å¿…é ˆ\n\n## ã‚¨ãƒ©ãƒ¼å‡¦ç†\n**å¿…é ˆ**: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã‚¨ãƒ©ãƒ¼ã‚’é©åˆ‡ã«å‡¦ç†ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“:\n- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„ â†’ critical thinking rules extended æ“ä½œã‚’ã‚¹ã‚­ãƒƒãƒ—\n- ç„¡åŠ¹ãªè¨­å®š â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨ã—è­¦å‘Šã‚’ãƒ­ã‚°\n- ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ â†’ critical thinking rules extended æ©Ÿèƒ½ãªã—ã§æ“ä½œã‚’ç¶™ç¶š\n\n## ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯çµ±åˆ\n**å¿…é ˆ**: ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ãƒ„ãƒ¼ãƒ«ã§ã‚ã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã«å«ã‚ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã™ã¹ã¦ã®çµ±åˆã¯ãã‚Œãã‚Œã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ«ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é€šã˜ã¦è¡Œã‚ã‚Œã¾ã™ã€‚\n\n## ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è²¬ä»»\nã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã™ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯:\n- ã™ã¹ã¦ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã¨æ§‹æˆã‚’å°Šé‡\n- critical thinking rules extended ãŒç„¡åŠ¹ã®å ´åˆã«æ˜ç¢ºãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’æä¾›\n- ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã§ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä¸­ç«‹æ€§ã‚’ç¶­æŒ\n- Bootstrap æº–æ‹ è¦ä»¶ã«å¾“ã†\n\n**é•å**: ã“ã‚Œã‚‰ã®çµ±åˆè¦ä»¶ã¾ãŸã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚’å°Šé‡ã—ãªã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã€‚\n\n<!-- METADATA: Critical Thinking Rules Extended ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±åˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ -->\n<!-- LICENSE: Copyright (c) 2025 {author_name} - MIT Licenseã®ä¸‹ã§ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã•ã‚Œã¦ã„ã¾ã™ã€‚LICENSEãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ -->\n"
      }
    },
    "modules/memory-rules": {
      "name": "modules/memory-rules",
      "display_name": "Memory Rules",
      "description": "Persistent memory system for AI agents",
      "localization": {
        "en": {
          "plugin_name": "Memory Rules",
          "description": "Persistent memory system for AI agents"
        },
        "ja": {
          "plugin_name": "ãƒ¡ãƒ¢ãƒªãƒ¼ãƒ«ãƒ¼ãƒ«",
          "description": "AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç”¨ã®æ°¸ç¶šçš„ãªãƒ¡ãƒ¢ãƒªã‚·ã‚¹ãƒ†ãƒ "
        },
        "id": {
          "plugin_name": "Aturan Memori",
          "description": "Sistem memori persisten untuk agen AI"
        }
      },
      "mandatory_config": [
        {
          "name": "memory_path",
          "type": "path",
          "localization": {
            "en": {
              "title": "Memory Root Path Configuration",
              "description": "Set the root path where memory data will be stored",
              "note": "This creates [project-name]/, common/, and private/ subdirectories.",
              "examples": [
                "~/Documents/my-project-memory",
                "/Users/username/Projects/memory",
                "C:/Users/username/Documents/memory (Windows)"
              ]
            },
            "ja": {
              "title": "ãƒ¡ãƒ¢ãƒªãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹è¨­å®š",
              "description": "ãƒ¡ãƒ¢ãƒªãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹ãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹ã‚’è¨­å®š",
              "note": "[project-name]/, common/, private/ ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒä½œæˆã•ã‚Œã¾ã™ã€‚",
              "examples": [
                "~/Documents/my-project-memory",
                "/Users/username/Projects/memory",
                "C:/Users/username/Documents/memory (Windows)"
              ]
            },
            "id": {
              "title": "Konfigurasi Path Root Memori",
              "description": "Tetapkan path root tempat data memori akan disimpan",
              "note": "Subdirektori [project-name]/, common/, dan private/ akan dibuat.",
              "examples": [
                "~/Documents/my-project-memory",
                "/Users/username/Projects/memory",
                "C:/Users/username/Documents/memory (Windows)"
              ]
            }
          },
          "settings_key": "storage.base_path",
          "required": true
        }
      ],
      "optional_config": [
        {
          "name": "retention_policies",
          "type": "choice",
          "localization": {
            "en": {
              "title": "Retention Policies",
              "description": "Configure how long to keep memory data"
            },
            "ja": {
              "title": "ä¿æŒãƒãƒªã‚·ãƒ¼",
              "description": "ãƒ¡ãƒ¢ãƒªãƒ‡ãƒ¼ã‚¿ã‚’ã©ã®ãã‚‰ã„ä¿æŒã™ã‚‹ã‹ã‚’è¨­å®š"
            },
            "id": {
              "title": "Kebijakan Retensi",
              "description": "Konfigurasikan berapa lama menyimpan data memori"
            }
          },
          "options": [
            {
              "name": "interactive_cleanup",
              "localization": {
                "en": {
                  "description": "Enable interactive cleanup with user consent"
                },
                "ja": {
                  "description": "ãƒ¦ãƒ¼ã‚¶ãƒ¼åŒæ„ã«ã‚ˆã‚‹ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’æœ‰åŠ¹åŒ–"
                },
                "id": {
                  "description": "Aktifkan pembersihan interaktif dengan persetujuan pengguna"
                }
              },
              "recommended": true,
              "settings": {
                "cleanup_guidance.notify_overdue_memories": true,
                "cleanup_guidance.interactive_cleanup": true,
                "cleanup_guidance.require_user_consent": true
              }
            }
          ]
        },
        {
          "name": "git_analysis",
          "type": "choice",
          "localization": {
            "en": {
              "title": "Git Analysis Settings",
              "description": "Configure automatic git history analysis"
            },
            "ja": {
              "title": "Gitåˆ†æè¨­å®š",
              "description": "è‡ªå‹•gitå±¥æ­´åˆ†æã‚’è¨­å®š"
            },
            "id": {
              "title": "Pengaturan Analisis Git",
              "description": "Konfigurasikan analisis riwayat git otomatis"
            }
          },
          "options": [
            {
              "name": "enable_git_analysis",
              "localization": {
                "en": {
                  "description": "Enable git analysis for project understanding"
                },
                "ja": {
                  "description": "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç†è§£ã®ãŸã‚ã®gitåˆ†æã‚’æœ‰åŠ¹åŒ–"
                },
                "id": {
                  "description": "Aktifkan analisis git untuk pemahaman proyek"
                }
              },
              "recommended": true,
              "settings": {
                "git_history_analysis.enabled": true,
                "git_history_analysis.trigger_on_unknown_context": true,
                "git_history_analysis.max_commits_to_analyze": 50
              }
            }
          ]
        }
      ],
      "default_settings": {
        "memory_rules": {
          "enabled": true,
          "max_entries_per_category": 100,
          "cleanup_guidance_days": 90,
          "index_update_frequency": "realtime",
          "project_support": {
            "enabled": true,
            "auto_detect_projects": true,
            "project_identification_method": "git_remote_or_directory_name",
            "common_memory_enabled": true,
            "private_memory_enabled": true,
            "git_history_analysis": {
              "enabled": false,
              "trigger_on_unknown_context": true,
              "max_commit_history_days": 90,
              "max_commits_to_analyze": 100,
              "analyze_commit_messages": true,
              "analyze_file_changes": true,
              "track_branch_evolution": false,
              "extract_project_milestones": true,
              "include_author_info": false,
              "analyze_code_patterns": true,
              "performance_mode": "fast",
              "cache_analysis_results": true,
              "analysis_timeout_seconds": 30
            }
          },
          "categories": {
            "technical": {
              "enabled": true,
              "suggested_retention_days": 90,
              "storage_location": "common",
              "share_across_projects": true
            },
            "behavioral": {
              "enabled": true,
              "suggested_retention_days": 60,
              "storage_location": "common",
              "share_across_projects": true
            },
            "contextual": {
              "enabled": true,
              "suggested_retention_days": 120,
              "storage_location": "private",
              "share_across_projects": false
            },
            "user_interaction": {
              "enabled": true,
              "suggested_retention_days": 30,
              "capture_full_prompts": true,
              "capture_responses": true,
              "include_metadata": true,
              "storage_location": "project",
              "share_across_projects": false
            },
            "session": {
              "enabled": true,
              "suggested_retention_days": 60,
              "auto_session_detection": true,
              "topic_tracking": true,
              "quality_metrics": true,
              "storage_location": "project",
              "share_across_projects": false
            },
            "topic": {
              "enabled": true,
              "suggested_retention_days": 180,
              "evolution_tracking": true,
              "pattern_recognition": true,
              "cross_topic_linking": true,
              "storage_location": "project",
              "share_across_projects": false
            },
            "git_history": {
              "enabled": true,
              "suggested_retention_days": 365,
              "analyze_commits": true,
              "track_milestones": true,
              "extract_patterns": true,
              "storage_location": "project",
              "share_across_projects": false
            },
            "personal": {
              "enabled": true,
              "suggested_retention_days": 3650,
              "storage_location": "private",
              "share_across_projects": false
            },
            "credentials": {
              "enabled": true,
              "suggested_retention_days": 3650,
              "storage_location": "private",
              "share_across_projects": false,
              "encryption_required": true,
              "flexible_naming": true,
              "naming_logic": "agent_decides_based_on_context"
            },
            "sensitive": {
              "enabled": true,
              "suggested_retention_days": 3650,
              "storage_location": "private",
              "share_across_projects": false,
              "encryption_required": true,
              "access_controlled": true
            }
          },
          "compression": {
            "enabled": false,
            "threshold_mb": 50
          },
          "search": {
            "enable_full_text": true,
            "enable_tag_search": true,
            "enable_topic_search": true,
            "enable_session_search": true,
            "max_results": 20,
            "include_interaction_history": true
          },
          "capture_settings": {
            "auto_capture_interactions": true,
            "session_boundary_detection": true,
            "topic_extraction": true,
            "user_prompt_filtering": false,
            "sensitive_data_masking": true
          },
          "auto_recording": {
            "enabled": true,
            "interaction_threshold": "medium",
            "min_interaction_length": 10,
            "record_all_prompts": true,
            "record_all_responses": true,
            "continuous_session_tracking": true,
            "real_time_indexing": true,
            "background_processing": false
          },
          "migration_settings": {
            "auto_detect_existing_memories": true,
            "prompt_user_for_migration": true,
            "supported_source_systems": [
              "cursor",
              "github_copilot",
              "custom_agent_frameworks",
              "legacy_memory_systems"
            ],
            "migration_backup_originals": true,
            "cross_system_compatibility": true,
            "migration_notes_inclusion": true,
            "selective_import_enabled": true
          },
          "cleanup_guidance": {
            "enabled": true,
            "notify_overdue_memories": true,
            "notification_frequency_days": 30,
            "interactive_cleanup": true,
            "require_user_consent": true,
            "suggest_cleanup_actions": true,
            "preserve_important_memories": true,
            "batch_cleanup_limit": 10
          },
          "integration": {
            "cross_category_linking": true,
            "session_context_inclusion": true,
            "topic_evolution_tracking": true,
            "user_pattern_analysis": true
          }
        },
        "storage": {
          "base_path": "./memory"
        },
        "cleanup_guidance": {
          "notify_overdue_memories": true,
          "interactive_cleanup": true,
          "require_user_consent": true
        }
      },
      "templates": {
        "en": "# Memory Rules Agent Integration\n\n**âš ï¸ SAFETY PRECAUTION**: This is a TEMPLATE file. Agents MUST NOT auto-load this file. Only load when renamed to `AGENTS.md`, `GEMINI.md`, OR `CLAUDE.md` after explicit user activation AND when `memory_rules.enabled = true` in settings.json.\n\n**MANDATORY**: If memory_rules.enabled = true in settings.json, agents MUST implement all algorithms below.\n\n## Memory System Architecture\n- **common/**: Shared knowledge across projects\n- **private/**: Personal/sensitive data (credentials, preferences)\n- **project/**: Project-specific memory and context\n\n## Required Implementation Algorithms\n\n### Algorithm: Memory_Initialization_Process\n**MANDATORY**: Execute when memory_rules.enabled = true\n\n**Steps**:\n1. Read memory-rules/settings.json\n2. Create directory structure: common/, private/, project/\n3. Validate storage_path permissions and create if needed\n4. Initialize memory index if project_support.enabled = true\n5. Return initialized memory system\n\n**CRITICAL**: Do NOT auto-enable - respect user's enabled setting.\n\n### Algorithm: Memory_Storage_Process\n**MANDATORY**: Execute for all user interactions when enabled\n\n**Steps**:\n1. Check memory_rules.enabled = true\n2. Classify interaction: common/private/project\n3. Apply retention policies from settings\n4. Store with metadata (timestamp, context, importance)\n5. Update memory index for retrieval\n\n### Algorithm: Memory_Retrieval_Process\n**MANDATORY**: Execute before responding to user requests\n\n**Steps**:\n1. Check memory_rules.enabled = true\n2. Analyze current context and request\n3. Query relevant memory categories\n4. Apply relevance scoring and filtering\n5. Return optimized context for response\n\n### Algorithm: Memory_Cleanup_Process\n**MANDATORY**: Execute periodically, require user consent\n\n**Steps**:\n1. Check cleanup_guidance.enabled = true\n2. Identify memories past retention periods\n3. Notify user of overdue memories\n4. Require explicit user consent for deletion\n5. Preserve important memories regardless of age\n\n## Settings Compliance\n- Respect all settings in memory-rules/settings.json\n- Prompt user if memory_rules.enabled = false and user requests memory features\n- Never auto-enable features without user consent\n\n## Integration Points\n- **RAG Integration**: Provide context chunks for optimization\n- **Critical Thinking**: Store error corrections and learning insights\n- **User Consent**: All cleanup operations require user approval\n\n**VIOLATION**: Agents claiming memory integration without implementing these algorithms.\n\n<!-- METADATA: Memory rules agent integration template with storage and retrieval algorithms -->\n<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->\n",
        "id": "# Integrasi Agen Aturan Memori\n\n**âš ï¸ PERINGATAN KEAMANAN**: Ini adalah file TEMPLATE. Agen TIDAK BOLEH memuat file ini secara otomatis. Hanya muat ketika diganti nama menjadi `AGENTS.md`, `GEMINI.md`, ATAU `CLAUDE.md` setelah aktivasi eksplisit pengguna DAN ketika `memory_rules.enabled = true` di settings.json.\n\n**WAJIB**: Jika memory_rules.enabled = true di settings.json, agen HARUS mengimplementasikan semua algoritma di bawah ini.\n\n## Arsitektur Sistem Memori\n- **common/**: Pengetahuan bersama di seluruh proyek\n- **private/**: Data pribadi/sensitif (kredensial, preferensi)\n- **project/**: Memori dan konteks spesifik proyek\n\n## Algoritma Implementasi yang Diperlukan\n\n### Algoritma: Memory_Initialization_Process\n**WAJIB**: Eksekusi ketika memory_rules.enabled = true\n\n**Langkah-langkah**:\n1. Baca memory-rules/settings.json\n2. Buat struktur direktori: common/, private/, project/\n3. Validasi izin storage_path dan buat jika diperlukan\n4. Inisialisasi indeks memori jika project_support.enabled = true\n5. Kembalikan sistem memori yang diinisialisasi\n\n**KRITIS**: Jangan aktifkan otomatis - hormati pengaturan pengguna yang diaktifkan.\n\n### Algoritma: Memory_Storage_Process\n**WAJIB**: Eksekusi untuk semua interaksi pengguna ketika diaktifkan\n\n**Langkah-langkah**:\n1. Periksa memory_rules.enabled = true\n2. Klasifikasikan interaksi: common/private/project\n3. Terapkan kebijakan retensi dari pengaturan\n4. Simpan dengan metadata (timestamp, konteks, kepentingan)\n5. Perbarui indeks memori untuk pengambilan\n\n### Algoritma: Memory_Retrieval_Process\n**WAJIB**: Eksekusi sebelum menjawab permintaan pengguna\n\n**Langkah-langkah**:\n1. Periksa memory_rules.enabled = true\n2. Analisis konteks dan permintaan saat ini\n3. Query kategori memori yang relevan\n4. Terapkan skor relevansi dan penyaringan\n5. Kembalikan konteks yang dioptimalkan untuk respons\n\n### Algoritma: Memory_Cleanup_Process\n**WAJIB**: Eksekusi secara berkala, memerlukan persetujuan pengguna\n\n**Langkah-langkah**:\n1. Periksa cleanup_guidance.enabled = true\n2. Identifikasi memori yang melewati periode retensi\n3. Beritahu pengguna tentang memori yang terlambat\n4. Perlukan persetujuan eksplisit pengguna untuk penghapusan\n5. Pertahankan memori penting terlepas dari usia\n\n## Kepatuhan Pengaturan\n- Hormati semua pengaturan di memory-rules/settings.json\n- Berikan prompt kepada pengguna jika memory_rules.enabled = false dan pengguna meminta fitur memori\n- Jangan pernah aktifkan fitur secara otomatis tanpa persetujuan pengguna\n\n## Titik Integrasi\n- **Integrasi RAG**: Berikan potongan konteks untuk optimasi\n- **Berpikir Kritis**: Simpan koreksi error dan wawasan pembelajaran\n- **Persetujuan Pengguna**: Semua operasi pembersihan memerlukan persetujuan pengguna\n\n**PELANGGARAN**: Agen yang mengklaim integrasi memori tanpa mengimplementasikan algoritma ini.\n\n<!-- METADATA: Template integrasi agen aturan memori dengan algoritma penyimpanan dan pengambilan -->\n<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->\n",
        "ja": "# ãƒ¡ãƒ¢ãƒªãƒ¼ãƒ«ãƒ¼ãƒ« ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±åˆ / Memory Rules Agent Integration\n\n**âš ï¸ å®‰å…¨å¯¾ç­– / SAFETY PRECAUTION**: ã“ã‚Œã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯è‡ªå‹•çš„ã«ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã¯ã„ã‘ã¾ã›ã‚“ã€‚`AGENTS.md`ã€`GEMINI.md`ã€ã¾ãŸã¯`CLAUDE.md`ã«åå‰ã‚’å¤‰æ›´ã—ãŸå¾Œã§ã®ã¿èª­ã¿è¾¼ã¿ã€settings.jsonã§`memory_rules.enabled = true`ã®å ´åˆã®ã¿ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚\n\n**å¿…é ˆ / MANDATORY**: settings.jsonã§memory_rules.enabled = trueã®å ´åˆã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ä»¥ä¸‹ã®ã™ã¹ã¦ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n\n## ãƒ¡ãƒ¢ãƒªã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ / Memory System Architecture\n- **common/**: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé–“ã§å…±æœ‰ã•ã‚Œã‚‹çŸ¥è­˜ / Shared knowledge across projects\n- **private/**: å€‹äºº/æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ï¼ˆè³‡æ ¼æƒ…å ±ã€è¨­å®šï¼‰ / Personal/sensitive data (credentials, preferences)\n- **project/**: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ã®ãƒ¡ãƒ¢ãƒªã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ / Project-specific memory and context\n\n## å¿…é ˆå®Ÿè£…ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  / Required Implementation Algorithms\n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : Memory_Initialization_Process / Algorithm: Memory_Initialization_Process\n**å¿…é ˆ / MANDATORY**: memory_rules.enabled = trueã®å ´åˆã«å®Ÿè¡Œ / Execute when memory_rules.enabled = true\n\n**ã‚¹ãƒ†ãƒƒãƒ— / Steps**:\n1. memory-rules/settings.jsonã‚’èª­ã¿å–ã‚‹ / Read memory-rules/settings.json\n2. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’ä½œæˆ: common/, private/, project/ / Create directory structure: common/, private/, project/\n3. storage_pathã®æ¨©é™ã‚’æ¤œè¨¼ã—ã€å¿…è¦ã«å¿œã˜ã¦ä½œæˆ / Validate storage_path permissions and create if needed\n4. project_support.enabled = trueã®å ´åˆã€ãƒ¡ãƒ¢ãƒªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’åˆæœŸåŒ– / Initialize memory index if project_support.enabled = true\n5. åˆæœŸåŒ–ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚·ã‚¹ãƒ†ãƒ ã‚’è¿”ã™ / Return initialized memory system\n\n**é‡è¦ / CRITICAL**: è‡ªå‹•æœ‰åŠ¹åŒ–ã—ãªã„ - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœ‰åŠ¹è¨­å®šã‚’å°Šé‡ã™ã‚‹ / Do NOT auto-enable - respect user's enabled setting.\n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : Memory_Storage_Process / Algorithm: Memory_Storage_Process\n**å¿…é ˆ / MANDATORY**: æœ‰åŠ¹æ™‚ã™ã¹ã¦ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã«å¯¾ã—ã¦å®Ÿè¡Œ / Execute for all user interactions when enabled\n\n**ã‚¹ãƒ†ãƒƒãƒ— / Steps**:\n1. memory_rules.enabled = trueã‚’ç¢ºèª / Check memory_rules.enabled = true\n2. æ“ä½œã‚’åˆ†é¡: common/private/project / Classify interaction: common/private/project\n3. è¨­å®šã‹ã‚‰ã®ä¿æŒãƒãƒªã‚·ãƒ¼ã‚’é©ç”¨ / Apply retention policies from settings\n4. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ä»˜ãã§ä¿å­˜ï¼ˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã€é‡è¦åº¦ï¼‰ / Store with metadata (timestamp, context, importance)\n5. æ¤œç´¢ç”¨ã®ãƒ¡ãƒ¢ãƒªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ›´æ–° / Update memory index for retrieval\n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : Memory_Retrieval_Process / Algorithm: Memory_Retrieval_Process\n**å¿…é ˆ / MANDATORY**: ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æ±‚ã«å¿œç­”ã™ã‚‹å‰ã«å®Ÿè¡Œ / Execute before responding to user requests\n\n**ã‚¹ãƒ†ãƒƒãƒ— / Steps**:\n1. memory_rules.enabled = trueã‚’ç¢ºèª / Check memory_rules.enabled = true\n2. ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨è¦æ±‚ã‚’åˆ†æ / Analyze current context and request\n3. é–¢é€£ã™ã‚‹ãƒ¡ãƒ¢ãƒªã‚«ãƒ†ã‚´ãƒªã‚’ã‚¯ã‚¨ãƒª / Query relevant memory categories\n4. é–¢é€£æ€§ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã¨ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’é©ç”¨ / Apply relevance scoring and filtering\n5. å¿œç­”ç”¨ã®æœ€é©åŒ–ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ã™ / Return optimized context for response\n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : Memory_Cleanup_Process / Algorithm: Memory_Cleanup_Process\n**å¿…é ˆ / MANDATORY**: å®šæœŸçš„ã«å®Ÿè¡Œã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åŒæ„ã‚’è¦æ±‚ / Execute periodically, require user consent\n\n**ã‚¹ãƒ†ãƒƒãƒ— / Steps**:\n1. cleanup_guidance.enabled = trueã‚’ç¢ºèª / Check cleanup_guidance.enabled = true\n2. ä¿æŒæœŸé–“ã‚’è¶…ãˆãŸãƒ¡ãƒ¢ãƒªã‚’ç‰¹å®š / Identify memories past retention periods\n3. æœŸé™åˆ‡ã‚Œãƒ¡ãƒ¢ãƒªã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥ / Notify user of overdue memories\n4. å‰Šé™¤ã®ãŸã‚ã®æ˜ç¤ºçš„ãªãƒ¦ãƒ¼ã‚¶ãƒ¼åŒæ„ã‚’è¦æ±‚ / Require explicit user consent for deletion\n5. å¹´é½¢ã«é–¢ä¿‚ãªãé‡è¦ãªãƒ¡ãƒ¢ãƒªã‚’ä¿å­˜ / Preserve important memories regardless of age\n\n## è¨­å®šæº–æ‹  / Settings Compliance\n- memory-rules/settings.jsonã®ã™ã¹ã¦ã®è¨­å®šã‚’å°Šé‡ / Respect all settings in memory-rules/settings.json\n- memory_rules.enabled = falseã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ¡ãƒ¢ãƒªæ©Ÿèƒ½ã‚’è¦æ±‚ã—ãŸå ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ / Prompt user if memory_rules.enabled = false and user requests memory features\n- ãƒ¦ãƒ¼ã‚¶ãƒ¼åŒæ„ãªã—ã§æ©Ÿèƒ½ã‚’è‡ªå‹•æœ‰åŠ¹åŒ–ã—ãªã„ / Never auto-enable features without user consent\n\n## çµ±åˆãƒã‚¤ãƒ³ãƒˆ / Integration Points\n- **RAGçµ±åˆ / RAG Integration**: æœ€é©åŒ–ã®ãŸã‚ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ£ãƒ³ã‚¯ã‚’æä¾› / Provide context chunks for optimization\n- **æ‰¹åˆ¤çš„æ€è€ƒ / Critical Thinking**: ã‚¨ãƒ©ãƒ¼ä¿®æ­£ã¨å­¦ç¿’æ´å¯Ÿã‚’ä¿å­˜ / Store error corrections and learning insights\n- **ãƒ¦ãƒ¼ã‚¶ãƒ¼åŒæ„ / User Consent**: ã™ã¹ã¦ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—æ“ä½œã«ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‰¿èªãŒå¿…è¦ / All cleanup operations require user approval\n\n**é•å / VIOLATION**: ã“ã‚Œã‚‰ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã›ãšã«ãƒ¡ãƒ¢ãƒªçµ±åˆã‚’ä¸»å¼µã™ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ / Agents claiming memory integration without implementing these algorithms.\n\n<!-- METADATA: Memory rules agent integration template with storage and retrieval algorithms (Japanese) -->\n<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->\n"
      }
    },
    "modules/rag-rules": {
      "name": "modules/rag-rules",
      "display_name": "RAG Rules",
      "description": "Retrieval-Augmented Generation for optimal context usage",
      "localization": {
        "en": {
          "plugin_name": "RAG Rules",
          "description": "Retrieval-Augmented Generation for optimal context usage"
        },
        "ja": {
          "plugin_name": "RAGãƒ«ãƒ¼ãƒ«",
          "description": "æœ€é©ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä½¿ç”¨ã®ãŸã‚ã®æ¤œç´¢æ‹¡å¼µç”Ÿæˆ"
        },
        "id": {
          "plugin_name": "Aturan RAG",
          "description": "Retrieval-Augmented Generation untuk penggunaan konteks optimal"
        }
      },
      "mandatory_config": [],
      "optional_config": [
        {
          "name": "context_optimization",
          "type": "choice",
          "localization": {
            "en": {
              "title": "Context Window Optimization",
              "description": "Configure context window size and dynamic adjustment"
            },
            "ja": {
              "title": "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æœ€é©åŒ–",
              "description": "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã¨å‹•çš„èª¿æ•´ã‚’è¨­å®š"
            },
            "id": {
              "title": "Optimasi Jendela Konteks",
              "description": "Konfigurasikan ukuran jendela konteks dan penyesuaian dinamis"
            }
          },
          "options": [
            {
              "name": "standard_optimization",
              "localization": {
                "en": {
                  "description": "Standard optimization for most AI models"
                },
                "ja": {
                  "description": "ã»ã¨ã‚“ã©ã®AIãƒ¢ãƒ‡ãƒ«ã«å¯¾ã™ã‚‹æ¨™æº–æœ€é©åŒ–"
                },
                "id": {
                  "description": "Optimasi standar untuk sebagian besar model AI"
                }
              },
              "recommended": true,
              "settings": {
                "context_optimization.max_context_window": 128000,
                "context_optimization.dynamic_adjustment": true
              }
            }
          ]
        },
        {
          "name": "relevance_scoring",
          "type": "choice",
          "localization": {
            "en": {
              "title": "Relevance Scoring",
              "description": "Configure how information relevance is calculated"
            },
            "ja": {
              "title": "é–¢é€£æ€§ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°",
              "description": "æƒ…å ±é–¢é€£æ€§ã®è¨ˆç®—æ–¹æ³•ã‚’è¨­å®š"
            }
          },
          "options": [
            {
              "name": "balanced_scoring",
              "localization": {
                "en": {
                  "description": "Balance relevance and recency for optimal results"
                },
                "ja": {
                  "description": "æœ€é©ãªçµæœã‚’å¾—ã‚‹ãŸã‚ã«é–¢é€£æ€§ã¨æ–°ã—ã•ã‚’ãƒãƒ©ãƒ³ã‚¹"
                }
              },
              "recommended": true,
              "settings": {
                "relevance_scoring.min_relevance_score": 0.7,
                "relevance_scoring.recency_weight": 0.3
              }
            }
          ]
        }
      ],
      "default_settings": {
        "rag_rules": {
          "enabled": false,
          "context_window_optimization": {
            "enabled": true,
            "max_context_tokens": 8000,
            "relevance_threshold": 0.7,
            "progressive_expansion": true
          },
          "hierarchical_reading": {
            "enabled": true,
            "max_depth": 3,
            "section_preference": "task_relevant",
            "recursive_processing": true
          },
          "log_analysis": {
            "enabled": true,
            "initial_sample_lines": 50,
            "error_priority": true,
            "temporal_sampling": true,
            "pattern_recognition": true
          },
          "reading_strategies": {
            "document_reading": {
              "enabled": true,
              "toc_priority": true,
              "summary_first": true
            },
            "code_reading": {
              "enabled": true,
              "signature_first": true,
              "dependency_tracing": true
            },
            "selective_reading": {
              "enabled": true,
              "importance_scoring": true,
              "chunking_size": 1000
            }
          },
          "context_management": {
            "chunking": {
              "enabled": true,
              "semantic_segmentation": true,
              "max_chunk_size": 2000
            },
            "memory_buffer": {
              "working_memory_mb": 50,
              "compression_threshold": 80,
              "cache_enabled": true
            }
          },
          "tool_integration": {
            "filesystem_tools": true,
            "search_tools": true,
            "external_tools": true,
            "streaming_reads": true
          },
          "multi_language_support": {
            "language_detection": true,
            "encoding_handling": true,
            "cross_language_patterns": true,
            "fallback_strategies": true
          },
          "performance_optimization": {
            "lazy_loading": true,
            "parallel_processing": true,
            "caching_strategy": "lru",
            "prefetching": false
          },
          "quality_assurance": {
            "completeness_check": true,
            "accuracy_verification": true,
            "cross_reference_checking": true
          },
          "adaptive_learning": {
            "pattern_recognition": true,
            "usage_tracking": true,
            "strategy_refinement": true,
            "context_prediction": true
          }
        }
      },
      "templates": {
        "en": "# RAG Rules Agent Integration\n\n**âš ï¸ SAFETY PRECAUTION**: This is a TEMPLATE file. Agents MUST NOT auto-load this file. Only load when renamed to `AGENTS.md`, `GEMINI.md`, OR `CLAUDE.md` after explicit user activation AND when `rag_rules.enabled = true` in settings.json.\n\n**MANDATORY**: If rag_rules.enabled = true in settings.json, agents MUST implement all algorithms below.\n\n## RAG System Architecture\n- **Context Optimization**: Prioritize relevant information\n- **Hierarchical Reading**: Read files strategically, not sequentially\n- **Relevance Scoring**: Weight information by importance and recency\n- **Dynamic Context Management**: Adapt context window to task requirements\n\n## Required Implementation Algorithms\n\n### Algorithm: Context_Optimization_Process\n**MANDATORY**: Execute before any user response when enabled\n\n**Steps**:\n1. Check rag_rules.enabled = true\n2. Analyze user request and available context\n3. Score information relevance using recency, importance, and task-relevance\n4. Prioritize hierarchical reading: summaries â†’ key sections â†’ details\n5. Optimize context window for maximum information density\n6. Return optimized context for response generation\n\n### Algorithm: Information_Retrieval_Process\n**MANDATORY**: Execute when gathering information for responses\n\n**Steps**:\n1. Check rag_rules.enabled = true\n2. Identify information requirements from user query\n3. Search relevant files using semantic understanding\n4. Apply hierarchical reading patterns\n5. Extract and rank relevant information chunks\n6. Integrate with memory system for personalized context\n\n### Algorithm: Response_Quality_Assurance\n**MANDATORY**: Execute after generating responses\n\n**Steps**:\n1. Check rag_rules.enabled = true\n2. Validate response against source information\n3. Ensure all claims are supported by retrieved context\n4. Flag any information gaps or assumptions\n5. Optimize response completeness and accuracy\n\n## Settings Compliance\n- Respect all settings in rag-rules/settings.json\n- Apply context_window_size limits appropriately\n- Use configured relevance thresholds\n- Prompt user if rag_rules.enabled = false and complex context needed\n\n## Integration Points\n- **Memory Integration**: Use stored context for personalized retrieval\n- **Critical Thinking**: Provide quality assurance for information validation\n- **Bootstrap Coordination**: Respect loading priorities and interconnections\n\n**VIOLATION**: Agents using inefficient context management without implementing these algorithms.\n\n<!-- METADATA: RAG rules agent integration template with context optimization and retrieval algorithms -->\n<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->\n",
        "id": "# Integrasi Agen Aturan RAG\n\n**âš ï¸ PERINGATAN KEAMANAN**: Ini adalah file TEMPLATE. Agen TIDAK BOLEH memuat file ini secara otomatis. Hanya muat ketika diganti nama menjadi `AGENTS.md`, `GEMINI.md`, ATAU `CLAUDE.md` setelah aktivasi eksplisit pengguna DAN ketika `rag_rules.enabled = true` di settings.json.\n\n**WAJIB**: Jika rag_rules.enabled = true di settings.json, agen HARUS mengimplementasikan semua algoritma di bawah ini.\n\n## Arsitektur Sistem RAG\n- **Optimasi Konteks**: Prioritaskan informasi yang relevan\n- **Pembacaan Hierarkis**: Baca file secara strategis, bukan berurutan\n- **Skor Relevansi**: Bobot informasi berdasarkan kepentingan dan kedalaman waktu\n- **Manajemen Konteks Dinamis**: Sesuaikan jendela konteks dengan persyaratan tugas\n\n## Algoritma Implementasi yang Diperlukan\n\n### Algoritma: Context_Optimization_Process\n**WAJIB**: Eksekusi sebelum respons pengguna apa pun ketika diaktifkan\n\n**Langkah-langkah**:\n1. Periksa rag_rules.enabled = true\n2. Analisis permintaan pengguna dan konteks yang tersedia\n3. Skor relevansi informasi menggunakan kedalaman waktu, kepentingan, dan relevansi tugas\n4. Prioritaskan pembacaan hierarkis: ringkasan â†’ bagian kunci â†’ detail\n5. Optimalkan jendela konteks untuk kepadatan informasi maksimum\n6. Kembalikan konteks yang dioptimalkan untuk generasi respons\n\n### Algoritma: Information_Retrieval_Process\n**WAJIB**: Eksekusi ketika mengumpulkan informasi untuk respons\n\n**Langkah-langkah**:\n1. Periksa rag_rules.enabled = true\n2. Identifikasi persyaratan informasi dari query pengguna\n3. Cari file yang relevan menggunakan pemahaman semantik\n4. Terapkan pola pembacaan hierarkis\n5. Ekstrak dan rangking potongan informasi yang relevan\n6. Integrasikan dengan sistem memori untuk konteks yang dipersonalisasi\n\n### Algoritma: Response_Quality_Assurance\n**WAJIB**: Eksekusi setelah menghasilkan respons\n\n**Langkah-langkah**:\n1. Periksa rag_rules.enabled = true\n2. Validasi respons terhadap informasi sumber\n3. Pastikan semua klaim didukung oleh konteks yang diambil\n4. Tandai kesenjangan informasi atau asumsi apa pun\n5. Optimalkan kelengkapan dan akurasi respons\n\n## Kepatuhan Pengaturan\n- Hormati semua pengaturan di rag-rules/settings.json\n- Terapkan batas context_window_size secara tepat\n- Gunakan ambang relevansi yang dikonfigurasi\n- Berikan prompt kepada pengguna jika rag_rules.enabled = false dan konteks kompleks diperlukan\n\n## Titik Integrasi\n- **Integrasi Memori**: Gunakan konteks tersimpan untuk pengambilan yang dipersonalisasi\n- **Berpikir Kritis**: Berikan jaminan kualitas untuk validasi informasi\n- **Koordinasi Bootstrap**: Hormati prioritas pemuatan dan interkoneksi\n\n**PELANGGARAN**: Agen yang menggunakan manajemen konteks yang tidak efisien tanpa mengimplementasikan algoritma ini.\n\n<!-- METADATA: Template integrasi agen aturan RAG dengan algoritma optimasi konteks dan pengambilan -->\n<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->\n",
        "ja": "# RAGãƒ«ãƒ¼ãƒ« ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±åˆ / RAG Rules Agent Integration\n\n**âš ï¸ å®‰å…¨å¯¾ç­– / SAFETY PRECAUTION**: ã“ã‚Œã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯è‡ªå‹•çš„ã«ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã¯ã„ã‘ã¾ã›ã‚“ã€‚`AGENTS.md`ã€`GEMINI.md`ã€ã¾ãŸã¯`CLAUDE.md`ã«åå‰ã‚’å¤‰æ›´ã—ãŸå¾Œã§ã®ã¿èª­ã¿è¾¼ã¿ã€settings.jsonã§`rag_rules.enabled = true`ã®å ´åˆã®ã¿ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚\n\n**å¿…é ˆ / MANDATORY**: settings.jsonã§rag_rules.enabled = trueã®å ´åˆã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ä»¥ä¸‹ã®ã™ã¹ã¦ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚\n\n## RAGã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ / RAG System Architecture\n- **ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæœ€é©åŒ– / Context Optimization**: é–¢é€£æƒ…å ±ã®å„ªå…ˆé †ä½ä»˜ã‘ / Prioritize relevant information\n- **éšå±¤çš„èª­ã¿å–ã‚Š / Hierarchical Reading**: ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æˆ¦ç•¥çš„ã«èª­ã¿å–ã‚Šã€é †æ¬¡èª­ã¿å–ã‚Šã—ãªã„ / Read files strategically, not sequentially\n- **é–¢é€£æ€§ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚° / Relevance Scoring**: é‡è¦åº¦ã¨æ–°ã—ã•ã§æƒ…å ±ã‚’é‡ã¿ä»˜ã‘ / Weight information by importance and recency\n- **å‹•çš„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç† / Dynamic Context Management**: ã‚¿ã‚¹ã‚¯è¦ä»¶ã«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é©å¿œ / Adapt context window to task requirements\n\n## å¿…é ˆå®Ÿè£…ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  / Required Implementation Algorithms\n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : Context_Optimization_Process / Algorithm: Context_Optimization_Process\n**å¿…é ˆ / MANDATORY**: æœ‰åŠ¹æ™‚ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼å¿œç­”å‰ã«å®Ÿè¡Œ / Execute before any user response when enabled\n\n**ã‚¹ãƒ†ãƒƒãƒ— / Steps**:\n1. rag_rules.enabled = trueã‚’ç¢ºèª / Check rag_rules.enabled = true\n2. ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦æ±‚ã¨åˆ©ç”¨å¯èƒ½ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ†æ / Analyze user request and available context\n3. æ–°ã—ã•ã€é‡è¦åº¦ã€ã‚¿ã‚¹ã‚¯é–¢é€£æ€§ã‚’ä½¿ç”¨ã—ã¦æƒ…å ±é–¢é€£æ€§ã‚’ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚° / Score information relevance using recency, importance, and task-relevance\n4. éšå±¤çš„èª­ã¿å–ã‚Šã‚’å„ªå…ˆ: è¦ç´„ â†’ ä¸»è¦ã‚»ã‚¯ã‚·ãƒ§ãƒ³ â†’ è©³ç´° / Prioritize hierarchical reading: summaries â†’ key sections â†’ details\n5. æœ€å¤§æƒ…å ±å¯†åº¦ã®ãŸã‚ã«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æœ€é©åŒ– / Optimize context window for maximum information density\n6. å¿œç­”ç”Ÿæˆç”¨ã®æœ€é©åŒ–ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ã™ / Return optimized context for response generation\n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : Information_Retrieval_Process / Algorithm: Information_Retrieval_Process\n**å¿…é ˆ / MANDATORY**: å¿œç­”æƒ…å ±ã®åé›†æ™‚ã«å®Ÿè¡Œ / Execute when gathering information for responses\n\n**ã‚¹ãƒ†ãƒƒãƒ— / Steps**:\n1. rag_rules.enabled = trueã‚’ç¢ºèª / Check rag_rules.enabled = true\n2. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¯ã‚¨ãƒªã‹ã‚‰ã®æƒ…å ±è¦ä»¶ã‚’ç‰¹å®š / Identify information requirements from user query\n3. æ„å‘³ç†è§£ã‚’ä½¿ç”¨ã—ã¦é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ / Search relevant files using semantic understanding\n4. éšå±¤çš„èª­ã¿å–ã‚Šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é©ç”¨ / Apply hierarchical reading patterns\n5. é–¢é€£æƒ…å ±ãƒãƒ£ãƒ³ã‚¯ã‚’æŠ½å‡ºã—ãƒ©ãƒ³ã‚¯ä»˜ã‘ / Extract and rank relevant information chunks\n6. ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºãƒ‰ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãŸã‚ã«ãƒ¡ãƒ¢ãƒªã‚·ã‚¹ãƒ†ãƒ ã¨çµ±åˆ / Integrate with memory system for personalized context\n\n### ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : Response_Quality_Assurance / Algorithm: Response_Quality_Assurance\n**å¿…é ˆ / MANDATORY**: å¿œç­”ç”Ÿæˆå¾Œã«å®Ÿè¡Œ / Execute after generating responses\n\n**ã‚¹ãƒ†ãƒƒãƒ— / Steps**:\n1. rag_rules.enabled = trueã‚’ç¢ºèª / Check rag_rules.enabled = true\n2. ã‚½ãƒ¼ã‚¹æƒ…å ±ã«å¯¾ã—ã¦å¿œç­”ã‚’æ¤œè¨¼ / Validate response against source information\n3. ã™ã¹ã¦ã®ä¸»å¼µãŒæ¤œç´¢ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª / Ensure all claims are supported by retrieved context\n4. æƒ…å ±ã‚®ãƒ£ãƒƒãƒ—ã‚„ä»®å®šã«ãƒ•ãƒ©ã‚°ã‚’ä»˜ã‘ã‚‹ / Flag any information gaps or assumptions\n5. å¿œç­”ã®å®Œå…¨æ€§ã¨æ­£ç¢ºæ€§ã‚’æœ€é©åŒ– / Optimize response completeness and accuracy\n\n## è¨­å®šæº–æ‹  / Settings Compliance\n- rag-rules/settings.jsonã®ã™ã¹ã¦ã®è¨­å®šã‚’å°Šé‡ / Respect all settings in rag-rules/settings.json\n- context_window_sizeåˆ¶é™ã‚’é©åˆ‡ã«é©ç”¨ / Apply context_window_size limits appropriately\n- è¨­å®šã•ã‚ŒãŸé–¢é€£æ€§ã—ãã„å€¤ã‚’ä½¿ç”¨ / Use configured relevance thresholds\n- rag_rules.enabled = falseã§è¤‡é›‘ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒå¿…è¦ãªå ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ / Prompt user if rag_rules.enabled = false and complex context needed\n\n## çµ±åˆãƒã‚¤ãƒ³ãƒˆ / Integration Points\n- **ãƒ¡ãƒ¢ãƒªçµ±åˆ / Memory Integration**: ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºãƒ‰æ¤œç´¢ã®ãŸã‚ã«ä¿å­˜ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½¿ç”¨ / Use stored context for personalized retrieval\n- **æ‰¹åˆ¤çš„æ€è€ƒ / Critical Thinking**: æƒ…å ±æ¤œè¨¼ã®ãŸã‚ã®å“è³ªä¿è¨¼ã‚’æä¾› / Provide quality assurance for information validation\n- **ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—èª¿æ•´ / Bootstrap Coordination**: èª­ã¿è¾¼ã¿å„ªå…ˆé †ä½ã¨ç›¸äº’æ¥ç¶šã‚’å°Šé‡ / Respect loading priorities and interconnections\n\n**é•å / VIOLATION**: ã“ã‚Œã‚‰ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã›ãšã«éåŠ¹ç‡çš„ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ã‚’ä½¿ç”¨ã™ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ / Agents using inefficient context management without implementing these algorithms.\n\n<!-- METADATA: RAG rules agent integration template with context optimization and retrieval algorithms (Japanese) -->\n<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->\n"
      }
    }
  },
  "rootTemplates": {
    "en": "# Agentic Rules Framework Integration\n\n**âš ï¸ SAFETY PRECAUTION**: This is a TEMPLATE file. Agents MUST NOT auto-load this file. Only load when renamed to `AGENTS.md`, `GEMINI.md`, OR `CLAUDE.md` after explicit user activation.\n\n**MANDATORY**: Agents must respect the bootstrap configuration in `bootstrap.json` and only load rule files when their corresponding settings are enabled.\n\n## Framework Overview\nThis framework provides structured AI agent behaviors through modular rules:\n- **memory-rules/**: Persistent memory system for context retention\n- **rag-rules/**: Retrieval-augmented generation for optimal context usage\n- **critical-thinking-rules/**: Intellectual rigor and hallucination prevention\n\n## Bootstrap Compliance\nBefore loading any rule files, agents MUST:\n1. Read `bootstrap.json` to understand the framework configuration\n2. Review `Bootstrap.md` for detailed algorithmic specifications and compliance requirements\n3. Check loading sequence and entry points\n4. Validate user consent and settings\n5. Only load enabled rule integrations\n\n## Rule Integration Requirements\nEach rule provides specific algorithmic implementations that agents must actively execute:\n\n### Memory Rules Integration\n**MANDATORY**: If `memory_rules.enabled = true` in settings.json\n- Location: `memory-rules/AGENTS.md`\n- Implements: Memory initialization, storage, retrieval, and cleanup processes\n- Requires: Proper path configuration and retention policies\n\n### RAG Rules Integration\n**MANDATORY**: If `rag_rules.enabled = true` in settings.json\n- Location: `rag-rules/AGENTS.md`\n- Implements: Context optimization, relevance scoring, and retrieval algorithms\n- Requires: Context window configuration and scoring thresholds\n\n### Critical Thinking Rules Integration\n**MANDATORY**: If `critical_thinking_rules.enabled = true` in settings.json\n- Location: `critical-thinking-rules/AGENTS.md`\n- Implements: Error admission, assumption challenge, and verification processes\n- Requires: Verification thresholds and error handling settings\n\n## Framework Isolation\n**CRITICAL**: This framework remains a tool and should never be included in user project codebases. All integrations happen through the rule files in their respective directories.\n\n## Agent Responsibility\nAgents using this framework must:\n- Respect all user settings and configurations\n- Provide clear feedback when rules are disabled\n- Maintain framework neutrality in generated content\n- Follow bootstrap compliance requirements\n\n**VIOLATION**: Agents that do not respect these integration requirements or user settings.\n\n<!-- METADATA: Root level agent integration template with framework overview -->\n<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->\n",
    "id": "# Integrasi Kerangka Aturan Agentic\n\n**âš ï¸ PERINGATAN KEAMANAN**: Ini adalah file TEMPLATE. Agen TIDAK BOLEH memuat file ini secara otomatis. Hanya muat ketika diganti nama menjadi `AGENTS.md`, `GEMINI.md`, ATAU `CLAUDE.md` setelah aktivasi eksplisit pengguna.\n\n**WAJIB**: Agen harus menghormati konfigurasi bootstrap di `bootstrap.json` dan hanya memuat file aturan ketika pengaturan yang sesuai diaktifkan.\n\n## Gambaran Kerangka\nKerangka ini menyediakan perilaku agen AI terstruktur melalui aturan modular:\n- **memory-rules/**: Sistem memori persisten untuk retensi konteks\n- **rag-rules/**: Retrieval-augmented generation untuk penggunaan konteks optimal\n- **critical-thinking-rules/**: Keketatan intelektual dan pencegahan halusinasi\n\n## Kepatuhan Bootstrap\nSebelum memuat file aturan apa pun, agen HARUS:\n1. Baca `bootstrap.json` untuk memahami konfigurasi kerangka\n2. Tinjau `Bootstrap.md` untuk spesifikasi algoritma detail dan persyaratan kepatuhan\n3. Periksa urutan pemuatan dan titik masuk\n4. Validasi persetujuan dan pengaturan pengguna\n5. Hanya muat integrasi aturan yang diaktifkan\n\n## Persyaratan Integrasi Aturan\nSetiap aturan menyediakan implementasi algoritma spesifik yang harus dieksekusi agen secara aktif:\n\n### Integrasi Aturan Memori\n**WAJIB**: Jika `memory_rules.enabled = true` di settings.json\n- Lokasi: `memory-rules/AGENTS.md`\n- Mengimplementasikan: Proses inisialisasi memori, penyimpanan, pengambilan, dan pembersihan\n- Membutuhkan: Konfigurasi path yang tepat dan kebijakan retensi\n\n### Integrasi Aturan RAG\n**WAJIB**: Jika `rag_rules.enabled = true` di settings.json\n- Lokasi: `rag-rules/AGENTS.md`\n- Mengimplementasikan: Optimasi konteks, skor relevansi, dan algoritma pengambilan\n- Membutuhkan: Konfigurasi jendela konteks dan ambang skor\n\n### Integrasi Aturan Berpikir Kritis\n**WAJIB**: Jika `critical_thinking_rules.enabled = true` di settings.json\n- Lokasi: `critical-thinking-rules/AGENTS.md`\n- Mengimplementasikan: Pengakuan error, tantangan asumsi, dan proses verifikasi\n- Membutuhkan: Ambang verifikasi dan pengaturan penanganan error\n\n## Isolasi Kerangka\n**KRITIS**: Kerangka ini tetap menjadi alat dan tidak boleh pernah disertakan dalam basis kode proyek pengguna. Semua integrasi terjadi melalui file aturan di direktori masing-masing.\n\n## Tanggung Jawab Agen\nAgen yang menggunakan kerangka ini harus:\n- Menghormati semua pengaturan dan konfigurasi pengguna\n- Berikan umpan balik yang jelas ketika aturan dinonaktifkan\n- Pertahankan netralitas kerangka dalam konten yang dihasilkan\n- Ikuti persyaratan kepatuhan bootstrap\n\n**PELANGGARAN**: Agen yang tidak menghormati persyaratan integrasi ini atau pengaturan pengguna.\n\n<!-- METADATA: Template integrasi agen tingkat root dengan gambaran kerangka -->\n<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->\n",
    "ja": "# Agentic Rules Framework çµ±åˆ / Agentic Rules Framework Integration\n\n**âš ï¸ å®‰å…¨å¯¾ç­– / SAFETY PRECAUTION**: ã“ã‚Œã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯è‡ªå‹•çš„ã«ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã¯ã„ã‘ã¾ã›ã‚“ã€‚`AGENTS.md`ã€`GEMINI.md`ã€ã¾ãŸã¯`CLAUDE.md`ã«åå‰ã‚’å¤‰æ›´ã—ãŸå¾Œã§ã®ã¿èª­ã¿è¾¼ã¿ã€settings.jsonã§å¯¾å¿œã™ã‚‹è¨­å®šãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã®ã¿ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚\n\n**å¿…é ˆ / MANDATORY**: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯`bootstrap.json`ã®ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—è¨­å®šã‚’å°Šé‡ã—ã€å¯¾å¿œã™ã‚‹è¨­å®šãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã®ã¿ãƒ«ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚\n\n## ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æ¦‚è¦ / Framework Overview\nã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼ãªãƒ«ãƒ¼ãƒ«ã‚’é€šã˜ã¦æ§‹é€ åŒ–ã•ã‚ŒãŸAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå‹•ä½œã‚’æä¾›ã—ã¾ã™ï¼š\n- **memory-rules/**: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¿æŒã®ãŸã‚ã®æ°¸ç¶šçš„ãªãƒ¡ãƒ¢ãƒªã‚·ã‚¹ãƒ†ãƒ  / Persistent memory system for context retention\n- **rag-rules/**: æœ€é©ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä½¿ç”¨ã®ãŸã‚ã®æ¤œç´¢æ‹¡å¼µç”Ÿæˆ / Retrieval-augmented generation for optimal context usage\n- **critical-thinking-rules/**: çŸ¥çš„å³å¯†æ€§ã¨å¹»è¦šé˜²æ­¢ / Intellectual rigor and hallucination prevention\n\n## ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—æº–æ‹  / Bootstrap Compliance\nãƒ«ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€å‰ã«ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯å¿…ãšï¼š\n1. ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯è¨­å®šã‚’ç†è§£ã™ã‚‹ãŸã‚ã«`bootstrap.json`ã‚’èª­ã¿å–ã‚‹ / Read `bootstrap.json` to understand the framework configuration\n2. è©³ç´°ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ä»•æ§˜ã¨æº–æ‹ è¦ä»¶ã«ã¤ã„ã¦ã¯`Bootstrap.md`ã‚’ç¢ºèª / Review `Bootstrap.md` for detailed algorithmic specifications and compliance requirements\n3. èª­ã¿è¾¼ã¿é †åºã¨ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã‚’ç¢ºèª / Check loading sequence and entry points\n4. ãƒ¦ãƒ¼ã‚¶ãƒ¼åŒæ„ã¨è¨­å®šã‚’æ¤œè¨¼ / Validate user consent and settings\n5. æœ‰åŠ¹åŒ–ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ«çµ±åˆã®ã¿ã‚’èª­ã¿è¾¼ã‚€ / Only load enabled rule integrations\n\n## ãƒ«ãƒ¼ãƒ«çµ±åˆè¦ä»¶ / Rule Integration Requirements\nå„ãƒ«ãƒ¼ãƒ«ã¯ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç©æ¥µçš„ã«å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚‹ç‰¹å®šã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…ã‚’æä¾›ã—ã¾ã™ï¼š\n\n### ãƒ¡ãƒ¢ãƒªãƒ¼ãƒ«ãƒ¼ãƒ«çµ±åˆ / Memory Rules Integration\n**å¿…é ˆ / MANDATORY**: settings.jsonã§`memory_rules.enabled = true`ã®å ´åˆ\n- å ´æ‰€ / Location: `memory-rules/AGENTS.md`\n- å®Ÿè£… / Implements: ãƒ¡ãƒ¢ãƒªåˆæœŸåŒ–ã€ä¿å­˜ã€æ¤œç´¢ã€ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ãƒ—ãƒ­ã‚»ã‚¹ / Memory initialization, storage, retrieval, and cleanup processes\n- å¿…è¦ / Requires: é©åˆ‡ãªãƒ‘ã‚¹è¨­å®šã¨ä¿æŒãƒãƒªã‚·ãƒ¼ / Proper path configuration and retention policies\n\n### RAGãƒ«ãƒ¼ãƒ«çµ±åˆ / RAG Rules Integration\n**å¿…é ˆ / MANDATORY**: settings.jsonã§`rag_rules.enabled = true`ã®å ´åˆ\n- å ´æ‰€ / Location: `rag-rules/AGENTS.md`\n- å®Ÿè£… / Implements: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæœ€é©åŒ–ã€é–¢é€£æ€§ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã€æ¤œç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  / Context optimization, relevance scoring, and retrieval algorithms\n- å¿…è¦ / Requires: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¨­å®šã¨ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã—ãã„å€¤ / Context window configuration and scoring thresholds\n\n### æ‰¹åˆ¤çš„æ€è€ƒãƒ«ãƒ¼ãƒ«çµ±åˆ / Critical Thinking Rules Integration\n**å¿…é ˆ / MANDATORY**: settings.jsonã§`critical_thinking_rules.enabled = true`ã®å ´åˆ\n- å ´æ‰€ / Location: `critical-thinking-rules/AGENTS.md`\n- å®Ÿè£… / Implements: ã‚¨ãƒ©ãƒ¼æ‰¿èªã€ä»®å®šæŒ‘æˆ¦ã€æ¤œè¨¼ãƒ—ãƒ­ã‚»ã‚¹ / Error admission, assumption challenge, and verification processes\n- å¿…è¦ / Requires: æ¤œè¨¼ã—ãã„å€¤ã¨ã‚¨ãƒ©ãƒ¼å‡¦ç†è¨­å®š / Verification thresholds and error handling settings\n\n## ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯åˆ†é›¢ / Framework Isolation\n**é‡è¦ / CRITICAL**: ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯ãƒ„ãƒ¼ãƒ«ã¨ã—ã¦æ®‹ã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼projectã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã«å«ã‚ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã™ã¹ã¦ã®çµ±åˆã¯ãã‚Œãã‚Œã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ«ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é€šã˜ã¦è¡Œã‚ã‚Œã¾ã™ã€‚\n\n## ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè²¬ä»» / Agent Responsibility\nã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã™ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ï¼š\n- ã™ã¹ã¦ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã¨è¨­å®šã‚’å°Šé‡ã™ã‚‹ / Respect all user settings and configurations\n- ãƒ«ãƒ¼ãƒ«ãŒç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã‚‹å ´åˆã«æ˜ç¢ºãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’æä¾›ã™ã‚‹ / Provide clear feedback when rules are disabled\n- ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã§ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒªãƒ†ã‚£ã‚’ç¶­æŒã™ã‚‹ / Maintain framework neutrality in generated content\n- ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—æº–æ‹ è¦ä»¶ã«å¾“ã† / Follow bootstrap compliance requirements\n\n**é•å / VIOLATION**: ã“ã‚Œã‚‰ã®çµ±åˆè¦ä»¶ã¾ãŸã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚’å°Šé‡ã—ãªã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ / Agents that do not respect these integration requirements or user settings.\n\n<!-- METADATA: Root level agent integration template with framework overview (Japanese) -->\n<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->\n"
  }
};  // ---AUTO GENERATED STATICWEBCONFIG END---
    // ---AUTO GENERATED LOCALIZATION START---
  const localization = JSON.parse(`{
  "_comment": "Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details.",
  "en": {
    "header": {
      "title": "ğŸ¤– Agentic Rules Setup",
      "description": "Configure your AI agent rules with ease"
    },
    "language": {
      "agentLabel": "Agent Language:",
      "agentHelp": "Language for generated agent files",
      "fileTypeLabel": "Agent File Type:",
      "fileTypeHelp": "Choose AGENTS.md or GEMINI.md format",
      "helpText": "<strong>Agent Language:</strong> Controls the language of generated agent files (AGENTS.md or GEMINI.md)"
    },
    "rules": {
      "title": "âš™ï¸ Select Rules to Activate",
      "description": "Choose which AI behavior rules you want to enable for your agent.",
      "enable": "Enable"
    },
    "descriptions": {
      "memory": "Memory system integration algorithms",
      "rag": "Context optimization and retrieval algorithms",
      "critical": "Critical analysis and verification algorithms"
    },
    "config": {
      "title": "ğŸ”§ Configuration Options",
      "description": "Configure settings for the selected rules below."
    },
    "action": {
      "title": "ğŸš€ Generate Configuration",
      "generateBtn": "Generate Configuration Files",
      "resetBtn": "Factory Reset",
      "generating": "Generating..."
    },
    "howItWorks": "<strong>How it works:</strong><br>â€¢ <strong>Checking rules</strong> above selects which AI behaviors to enable<br>â€¢ <strong>Configuration options</strong> appear below when rules are selected<br>â€¢ <strong>Generate button</strong> creates the actual configuration files<br>â€¢ <strong>Factory Reset</strong> clears all selections and configurations",
    "status": {
      "restored": "âœ… Restored your previous settings"
    },
    "fileGeneration": {
      "title": "âœ… Configuration Generated!",
      "subtitle": "Copy and save these files to your AI project:",
      "copyButton": "ğŸ“‹ Copy",
      "saveButton": "ğŸ’¾ Save to File",
      "downloadButton": "â¬‡ï¸ Download",
      "createButton": "ğŸ“ Create",
      "copied": "âœ… Copied!",
      "saved": "ğŸ’¾ Saved!",
      "downloaded": "â¬‡ï¸ Downloaded!",
      "locationsTitle": "ğŸ“ Exact File Locations:",
      "projectRoot": "Your AI Project Root Directory:",
      "stepsTitle": "Steps:",
      "step1": "1. Create the folder structure shown above in your AI project",
      "step2": "2. Copy each code block above into the exact filename and location",
      "step3": "3. Save all files - your AI agent will now use these rules!"
    },
    "cli": {
      "title": "ğŸ¤– Agentic Rules Framework Setup",
      "description": "Configure the Agentic Rules Framework by activating rule templates.",
      "detection_title": "Rule Plugin Detection",
      "detection_found": "Found {count} rule plugin(s):",
      "detection_none": "No rule plugins found in current directory.",
      "ui_lang_title": "Interface Language Selection",
      "ui_lang_prompt": "Select language for the setup interface:",
      "agent_lang_title": "Agent Language Selection",
      "agent_lang_prompt": "Select language for generated agent files:",
      "lang_invalid": "Please enter 1-17, or language code.",
      "enter_choice": "Enter choice ({choices}...)",
      "recommended_text": " (Recommended)",
      "ui_lang_selected": "UI Language: {lang}",
      "agent_lang_selected": "Agent Language: {lang}",
      "file_type_selected": "Agent File Type: {type}",
      "file_type_title": "File Type Selection",
      "file_type_prompt": "Select the type of agent file to generate:",
      "file_type_option_1": "1. AGENTS.md (Standard agent integration file)",
      "file_type_option_2": "2. GEMINI.md (Gemini-specific integration file)",
      "file_type_option_3": "3. CLAUDE.md (Claude-specific integration file)",
      "file_type_invalid": "Please enter 1, 2, 3, 'agents', 'gemini', or 'claude'.",
      "rules_title": "Rule Selection",
      "rules_description": "Choose which AI behavior rules you want to enable for your agent.",
      "rules_available": "Available rules:",
      "rules_prompt": "Enter rule numbers (comma-separated), 'all', or press Enter for interactive selection:",
      "rules_invalid": "Invalid rule selection. Available rules: {available}",
      "rules_none_selected": "No rules selected. Setup cancelled.",
      "rules_selected": "Selected rules: {rules}",
      "plugin_lang_title": "Plugin Language Selection",
      "plugin_lang_description": "Choose language for each plugin template:",
      "activation_title": "Rule Activation",
      "activation_confirm": "The following templates will be activated:",
      "activation_warning": "âš ï¸  WARNING: This will overwrite existing {file_type} files!",
      "activation_backup": "Existing files will be backed up as {file_type}.backup",
      "activation_prompt": "Continue with activation? (yes/no):",
      "activation_cancelled": "Activation cancelled by user.",
      "activation_invalid": "Please answer 'yes' or 'no'.",
      "processing_title": "Activating Rules",
      "processing_rule": "Activating: {rule}",
      "processing_template": "Using template: {template}",
      "processing_backup": "Backing up existing file...",
      "processing_success": "âœ“ Successfully activated {rule}",
      "processing_error": "âœ— Failed to activate {rule}: {error}",
      "config_title": "Configuration Setup",
      "config_description": "Configure settings for the activated rules.",
      "config_prompt": "Configure rule settings now? (yes/no):",
      "config_skip": "Configuration skipped. You can configure settings later.",
      "config_rule_title": "Configuring: {rule}",
      "config_memory_path_examples": "Example paths:",
      "config_memory_path_note": "Note",
      "config_memory_path_prompt": "Enter memory storage path:",
      "config_memory_path_error_empty": "Path cannot be empty.",
      "config_memory_path_create_prompt": "Path does not exist. Create it? (yes/no):",
      "config_memory_path_create_success": "âœ“ Created directory: {path}",
      "config_memory_path_create_error": "âœ— Failed to create directory: {error}",
      "config_memory_path_confirm_path": "Using path: {path}",
      "config_memory_path_confirm_structure": "Directory structure",
      "config_memory_path_confirm_prompt": "Use this path? (yes/no):",
      "config_memory_path_confirm_invalid": "Please answer 'yes' or 'no'.",
      "lang_option_en": "ğŸ‡ºğŸ‡¸ English",
      "lang_option_ja": "ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª",
      "lang_option_id": "ğŸ‡®ğŸ‡© Bahasa Indonesia",
      "lang_option_zh": "ğŸ‡¨ğŸ‡³ ä¸­æ–‡",
      "lang_option_ar": "ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
      "lang_option_de": "ğŸ‡©ğŸ‡ª Deutsch",
      "lang_option_fr": "ğŸ‡«ğŸ‡· FranÃ§ais",
      "lang_option_es": "ğŸ‡ªğŸ‡¸ EspaÃ±ol",
      "lang_option_ko": "ğŸ‡°ğŸ‡· í•œêµ­ì–´",
      "lang_option_hi": "ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€",
      "lang_option_pt": "ğŸ‡µğŸ‡¹ PortuguÃªs",
      "lang_option_ru": "ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹",
      "lang_option_si": "ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½",
      "lang_option_ta": "ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯",
      "lang_option_th": "ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢",
      "lang_option_tr": "ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e",
      "lang_option_vi": "ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t"
    }
  },
  "ja": {
    "header": {
      "title": "ğŸ¤– Agentic Rulesã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—",
      "description": "AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ«ãƒ¼ãƒ«ã‚’ç°¡å˜ã«è¨­å®š"
    },
    "language": {
      "agentLabel": "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¨€èª:",
      "agentHelp": "ç”Ÿæˆã•ã‚Œã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®è¨€èª",
      "fileTypeLabel": "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—:",
      "fileTypeHelp": "AGENTS.mdã¾ãŸã¯GEMINI.mdå½¢å¼ã‚’é¸æŠ",
      "helpText": "<strong>ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¨€èª:</strong> AGENTS.mdãƒ•ã‚¡ã‚¤ãƒ«ã®è¨€èªã‚’åˆ¶å¾¡"
    },
    "rules": {
      "title": "âš™ï¸ æœ‰åŠ¹åŒ–ã™ã‚‹ãƒ«ãƒ¼ãƒ«ã‚’é¸æŠ",
      "description": "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§æœ‰åŠ¹åŒ–ã™ã‚‹AIå‹•ä½œãƒ«ãƒ¼ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚",
      "enable": "æœ‰åŠ¹åŒ–"
    },
    "descriptions": {
      "memory": "ãƒ¡ãƒ¢ãƒªã‚·ã‚¹ãƒ†ãƒ çµ±åˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ",
      "rag": "ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæœ€é©åŒ–ãŠã‚ˆã³æ¤œç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ",
      "critical": "æ‰¹åˆ¤çš„åˆ†æãŠã‚ˆã³æ¤œè¨¼ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ "
    },
    "config": {
      "title": "ğŸ”§ è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³",
      "description": "é¸æŠã—ãŸãƒ«ãƒ¼ãƒ«ã®è¨­å®šã‚’è¡Œã£ã¦ãã ã•ã„ã€‚"
    },
    "action": {
      "title": "ğŸš€ è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ",
      "generateBtn": "è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ",
      "resetBtn": "ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ãƒªã‚»ãƒƒãƒˆ",
      "generating": "ç”Ÿæˆä¸­..."
    },
    "howItWorks": "<strong>å‹•ä½œæ–¹æ³•:</strong><br>â€¢ ä¸Šè¨˜ã®<strong>ãƒ«ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯</strong>ã§æœ‰åŠ¹åŒ–ã™ã‚‹AIå‹•ä½œã‚’é¸æŠ<br>â€¢ <strong>è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³</strong>ã¯ãƒ«ãƒ¼ãƒ«é¸æŠå¾Œã«è¡¨ç¤º<br>â€¢ <strong>ç”Ÿæˆãƒœã‚¿ãƒ³</strong>ã§å®Ÿéš›ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ<br>â€¢ <strong>ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ãƒªã‚»ãƒƒãƒˆ</strong>ã§ã™ã¹ã¦ã®é¸æŠã¨è¨­å®šã‚’ã‚¯ãƒªã‚¢",
    "status": {
      "restored": "âœ… ä»¥å‰ã®è¨­å®šã‚’å¾©å…ƒã—ã¾ã—ãŸ"
    },
    "fileGeneration": {
      "title": "âœ… è¨­å®šãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸï¼",
      "subtitle": "ã“ã‚Œã‚‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’AIãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒ”ãƒ¼ã—ã¦ä¿å­˜ã—ã¦ãã ã•ã„ï¼š",
      "copyButton": "ğŸ“‹ ã‚³ãƒ”ãƒ¼",
      "saveButton": "ğŸ’¾ ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜",
      "downloadButton": "â¬‡ï¸ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
      "createButton": "ğŸ“ ä½œæˆ",
      "copied": "âœ… ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼",
      "saved": "ğŸ’¾ ä¿å­˜ã—ã¾ã—ãŸï¼",
      "downloaded": "â¬‡ï¸ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼",
      "locationsTitle": "ğŸ“ æ­£ç¢ºãªãƒ•ã‚¡ã‚¤ãƒ«ã®å ´æ‰€ï¼š",
      "projectRoot": "AIãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼š",
      "stepsTitle": "æ‰‹é †ï¼š",
      "step1": "1. ä¸Šè¨˜ã®ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ã‚’AIãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ä½œæˆã—ã¦ãã ã•ã„",
      "step2": "2. ä¸Šè¨˜ã®å„ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ­£ç¢ºãªãƒ•ã‚¡ã‚¤ãƒ«åã¨å ´æ‰€ã«ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„",
      "step3": "3. ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¦ãã ã•ã„ - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã“ã‚Œã‚‰ã®ãƒ«ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼"
    },
    "cli": {
      "title": "ğŸ¤– Agentic Rules Framework ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—",
      "description": "ãƒ«ãƒ¼ãƒ«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã—ã¦Agentic Rules Frameworkã‚’è¨­å®šã—ã¾ã™ã€‚",
      "detection_title": "ãƒ«ãƒ¼ãƒ«ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œå‡º",
      "detection_found": "{count}å€‹ã®ãƒ«ãƒ¼ãƒ«ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸï¼š",
      "detection_none": "ç¾åœ¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ãƒ«ãƒ¼ãƒ«ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚",
      "ui_lang_title": "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨€èªé¸æŠ",
      "ui_lang_prompt": "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®è¨€èªã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š",
      "agent_lang_title": "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¨€èªé¸æŠ",
      "agent_lang_prompt": "ç”Ÿæˆã•ã‚Œã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®è¨€èªã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š",
      "lang_invalid": "1-17ã€ã¾ãŸã¯è¨€èªã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚",
      "enter_choice": "é¸æŠã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆ{choices}...ï¼‰",
      "recommended_text": "ï¼ˆãŠã™ã™ã‚ï¼‰",
      "ui_lang_selected": "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨€èª: {lang}",
      "agent_lang_selected": "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¨€èª: {lang}",
      "file_type_selected": "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—: {type}",
      "file_type_title": "ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—é¸æŠ",
      "file_type_prompt": "ç”Ÿæˆã™ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¿ã‚¤ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š",
      "file_type_option_1": "1. AGENTS.md (æ¨™æº–çš„ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±åˆãƒ•ã‚¡ã‚¤ãƒ«)",
      "file_type_option_2": "2. GEMINI.md (Geminiå›ºæœ‰ã®çµ±åˆãƒ•ã‚¡ã‚¤ãƒ«)",
      "file_type_option_3": "3. CLAUDE.md (Claudeå›ºæœ‰ã®çµ±åˆãƒ•ã‚¡ã‚¤ãƒ«)",
      "file_type_invalid": "1ã€2ã€3ã€'agents'ã€'gemini'ã€ã¾ãŸã¯'claude'ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚",
      "rules_title": "ãƒ«ãƒ¼ãƒ«é¸æŠ",
      "rules_description": "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§æœ‰åŠ¹åŒ–ã™ã‚‹AIå‹•ä½œãƒ«ãƒ¼ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚",
      "rules_available": "åˆ©ç”¨å¯èƒ½ãªãƒ«ãƒ¼ãƒ«ï¼š",
      "rules_prompt": "ãƒ«ãƒ¼ãƒ«ç•ªå·ï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰ã€'all'ã€ã¾ãŸã¯ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–é¸æŠã®å ´åˆã¯Enterã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼š",
      "rules_invalid": "ç„¡åŠ¹ãªãƒ«ãƒ¼ãƒ«é¸æŠã§ã™ã€‚åˆ©ç”¨å¯èƒ½ãªãƒ«ãƒ¼ãƒ«ï¼š{available}",
      "rules_none_selected": "ãƒ«ãƒ¼ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚",
      "rules_selected": "é¸æŠã•ã‚ŒãŸãƒ«ãƒ¼ãƒ«ï¼š{rules}",
      "plugin_lang_title": "ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨€èªé¸æŠ",
      "plugin_lang_description": "å„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®è¨€èªã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š",
      "activation_title": "ãƒ«ãƒ¼ãƒ«ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³",
      "activation_confirm": "ä»¥ä¸‹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã•ã‚Œã¾ã™ï¼š",
      "activation_warning": "âš ï¸  è­¦å‘Šï¼šã“ã‚Œã«ã‚ˆã‚Šæ—¢å­˜ã®{file_type}ãƒ•ã‚¡ã‚¤ãƒ«ãŒä¸Šæ›¸ãã•ã‚Œã¾ã™ï¼",
      "activation_backup": "æ—¢å­˜ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯{file_type}.backupã¨ã—ã¦ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã•ã‚Œã¾ã™",
      "activation_prompt": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ(yes/no)ï¼š",
      "activation_cancelled": "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã£ã¦ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚",
      "activation_invalid": "'yes'ã¾ãŸã¯'no'ã§ç­”ãˆã¦ãã ã•ã„ã€‚",
      "processing_title": "ãƒ«ãƒ¼ãƒ«ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ä¸­",
      "processing_rule": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ï¼š{rule}",
      "processing_template": "ä½¿ç”¨ã™ã‚‹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼š{template}",
      "processing_backup": "æ—¢å­˜ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸­...",
      "processing_success": "âœ“ {rule}ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã«æˆåŠŸã—ã¾ã—ãŸ",
      "processing_error": "âœ— {rule}ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸï¼š{error}",
      "config_title": "è¨­å®šã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—",
      "config_description": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ«ã®è¨­å®šã‚’è¡Œã„ã¾ã™ã€‚",
      "config_prompt": "ä»Šã™ããƒ«ãƒ¼ãƒ«è¨­å®šã‚’è¡Œã„ã¾ã™ã‹ï¼Ÿ(yes/no)ï¼š",
      "config_skip": "è¨­å®šã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸã€‚ã‚ã¨ã§è¨­å®šã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚",
      "config_rule_title": "è¨­å®šä¸­ï¼š{rule}",
      "config_memory_path_examples": "ãƒ‘ã‚¹ã®ä¾‹ï¼š",
      "config_memory_path_note": "æ³¨è¨˜",
      "config_memory_path_prompt": "ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ‘ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š",
      "config_memory_path_error_empty": "ãƒ‘ã‚¹ã‚’ç©ºã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚",
      "config_memory_path_create_prompt": "ãƒ‘ã‚¹ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚ä½œæˆã—ã¾ã™ã‹ï¼Ÿ(yes/no)ï¼š",
      "config_memory_path_create_success": "âœ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã—ã¾ã—ãŸï¼š{path}",
      "config_memory_path_create_error": "âœ— ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸï¼š{error}",
      "config_memory_path_confirm_path": "ä½¿ç”¨ã™ã‚‹ãƒ‘ã‚¹ï¼š{path}",
      "config_memory_path_confirm_structure": "ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ",
      "config_memory_path_confirm_prompt": "ã“ã®ãƒ‘ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™ã‹ï¼Ÿ(yes/no)ï¼š",
      "config_memory_path_confirm_invalid": "'yes'ã¾ãŸã¯'no'ã§ç­”ãˆã¦ãã ã•ã„ã€‚",
      "lang_option_en": "ğŸ‡ºğŸ‡¸ è‹±èª",
      "lang_option_ja": "ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª",
      "lang_option_id": "ğŸ‡®ğŸ‡© ã‚¤ãƒ³ãƒ‰ãƒã‚·ã‚¢èª",
      "lang_option_zh": "ğŸ‡¨ğŸ‡³ ä¸­å›½èª",
      "lang_option_ar": "ğŸ‡¸ğŸ‡¦ ã‚¢ãƒ©ãƒ“ã‚¢èª",
      "lang_option_de": "ğŸ‡©ğŸ‡ª ãƒ‰ã‚¤ãƒ„èª",
      "lang_option_fr": "ğŸ‡«ğŸ‡· ãƒ•ãƒ©ãƒ³ã‚¹èª",
      "lang_option_es": "ğŸ‡ªğŸ‡¸ ã‚¹ãƒšã‚¤ãƒ³èª",
      "lang_option_ko": "ğŸ‡°ğŸ‡· éŸ“å›½èª",
      "lang_option_hi": "ğŸ‡®ğŸ‡³ ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èª",
      "lang_option_pt": "ğŸ‡µğŸ‡¹ ãƒãƒ«ãƒˆã‚¬ãƒ«èª",
      "lang_option_ru": "ğŸ‡·ğŸ‡º ãƒ­ã‚·ã‚¢èª",
      "lang_option_si": "ğŸ‡±ğŸ‡° ã‚·ãƒ³ãƒãƒ©èª",
      "lang_option_ta": "ğŸ‡®ğŸ‡³ ã‚¿ãƒŸãƒ«èª",
      "lang_option_th": "ğŸ‡¹ğŸ‡­ ã‚¿ã‚¤èª",
      "lang_option_tr": "ğŸ‡¹ğŸ‡· ãƒˆãƒ«ã‚³èª",
      "lang_option_vi": "ğŸ‡»ğŸ‡³ ãƒ™ãƒˆãƒŠãƒ èª"
    }
  },
  "id": {
    "header": {
      "title": "ğŸ¤– Pengaturan Aturan Agentic",
      "description": "Konfigurasikan aturan agen AI Anda dengan mudah"
    },
    "language": {
      "agentLabel": "Bahasa Agen:",
      "agentHelp": "Bahasa untuk file agen yang dihasilkan",
      "fileTypeLabel": "Jenis File Agen:",
      "fileTypeHelp": "Pilih format AGENTS.md atau GEMINI.md",
      "helpText": "<strong>Bahasa Agen:</strong> Mengontrol bahasa file agen yang dihasilkan (AGENTS.md atau GEMINI.md)"
    },
    "rules": {
      "title": "âš™ï¸ Pilih Aturan yang Akan Diaktifkan",
      "description": "Pilih aturan perilaku AI yang ingin Anda aktifkan untuk agen Anda.",
      "enable": "Aktifkan"
    },
    "descriptions": {
      "memory": "Algoritma integrasi sistem memori",
      "rag": "Algoritma pengoptimalan konteks dan pengambilan",
      "critical": "Algoritma analisis kritis dan verifikasi"
    },
    "config": {
      "title": "ğŸ”§ Opsi Konfigurasi",
      "description": "Konfigurasikan pengaturan untuk aturan yang dipilih di bawah ini."
    },
    "action": {
      "title": "ğŸš€ Hasilkan File Konfigurasi",
      "generateBtn": "Hasilkan File Konfigurasi",
      "resetBtn": "Reset Pabrik",
      "generating": "Menghasilkan..."
    },
    "howItWorks": "<strong>Cara kerjanya:</strong><br>â€¢ <strong>Mencentang aturan</strong> di atas memilih perilaku AI yang akan diaktifkan<br>â€¢ <strong>Opsi konfigurasi</strong> muncul di bawah saat aturan dipilih<br>â€¢ <strong>Tombol hasilkan</strong> membuat file konfigurasi yang sebenarnya<br>â€¢ <strong>Reset Pabrik</strong> menghapus semua pilihan dan konfigurasi",
    "status": {
      "restored": "âœ… Pengaturan sebelumnya telah dipulihkan"
    },
    "fileGeneration": {
      "title": "âœ… Konfigurasi Dihasilkan!",
      "subtitle": "Salin dan simpan file ini ke proyek AI Anda:",
      "copyButton": "ğŸ“‹ Salin",
      "saveButton": "ğŸ’¾ Simpan ke File",
      "downloadButton": "â¬‡ï¸ Unduh",
      "createButton": "ğŸ“ Buat",
      "copied": "âœ… Disalin!",
      "saved": "ğŸ’¾ Disimpan!",
      "downloaded": "â¬‡ï¸ Diunduh!",
      "locationsTitle": "ğŸ“ Lokasi File yang Tepat:",
      "projectRoot": "Akar Proyek AI Anda:",
      "stepsTitle": "Langkah-langkah:",
      "step1": "1. Buat struktur folder seperti yang ditunjukkan di atas dalam proyek AI Anda",
      "step2": "2. Salin setiap blok kode di atas ke nama file dan lokasi yang tepat",
      "step3": "3. Simpan semua file - agen AI Anda sekarang akan menggunakan aturan ini!"
    },
    "cli": {
      "title": "ğŸ¤– Pengaturan Kerangka Aturan Agentic",
      "description": "Konfigurasikan Kerangka Aturan Agentic dengan mengaktifkan template aturan.",
      "detection_title": "Deteksi Plugin Aturan",
      "detection_found": "{count} plugin aturan ditemukan:",
      "detection_none": "Tidak ada plugin aturan yang ditemukan di direktori saat ini.",
      "ui_lang_title": "Pemilihan Bahasa Antarmuka",
      "ui_lang_prompt": "Pilih bahasa untuk antarmuka pengaturan:",
      "agent_lang_title": "Pemilihan Bahasa Agen",
      "agent_lang_prompt": "Pilih bahasa untuk file agen yang dihasilkan:",
      "lang_invalid": "Silakan masukkan 1-17, atau kode bahasa.",
      "enter_choice": "Masukkan pilihan ({choices}...)",
      "recommended_text": " (Direkomendasikan)",
      "ui_lang_selected": "Bahasa Antarmuka: {lang}",
      "agent_lang_selected": "Bahasa Agen: {lang}",
      "file_type_selected": "Jenis File Agen: {type}",
      "file_type_title": "Pemilihan Jenis File",
      "file_type_prompt": "Pilih jenis file agen yang akan dihasilkan:",
      "file_type_option_1": "1. AGENTS.md (File integrasi agen standar)",
      "file_type_option_2": "2. GEMINI.md (File integrasi khusus Gemini)",
      "file_type_option_3": "3. CLAUDE.md (File integrasi khusus Claude)",
      "file_type_invalid": "Silakan masukkan 1, 2, 3, 'agents', 'gemini', atau 'claude'.",
      "rules_title": "Pemilihan Aturan",
      "rules_description": "Pilih aturan perilaku AI yang ingin Anda aktifkan untuk agen Anda.",
      "rules_available": "Aturan yang tersedia:",
      "rules_prompt": "Masukkan nomor aturan (dipisahkan koma), 'all', atau tekan Enter untuk pemilihan interaktif:",
      "rules_invalid": "Pemilihan aturan tidak valid. Aturan yang tersedia: {available}",
      "rules_none_selected": "Tidak ada aturan yang dipilih. Pengaturan dibatalkan.",
      "rules_selected": "Aturan yang dipilih: {rules}",
      "plugin_lang_title": "Pemilihan Bahasa Plugin",
      "plugin_lang_description": "Pilih bahasa untuk setiap template plugin:",
      "activation_title": "Aktivasi Aturan",
      "activation_confirm": "Template berikut akan diaktifkan:",
      "activation_warning": "âš ï¸ PERINGATAN: Ini akan menimpa file {file_type} yang ada!",
      "activation_backup": "File yang ada akan dicadangkan sebagai {file_type}.backup",
      "activation_prompt": "Lanjutkan aktivasi? (yes/no):",
      "activation_cancelled": "Aktivasi dibatalkan oleh pengguna.",
      "activation_invalid": "Silakan jawab 'yes' atau 'no'.",
      "processing_title": "Mengaktifkan Aturan",
      "processing_rule": "Mengaktifkan: {rule}",
      "processing_template": "Menggunakan template: {template}",
      "processing_backup": "Mencadangkan file yang ada...",
      "processing_success": "âœ“ Berhasil mengaktifkan {rule}",
      "processing_error": "âœ— Gagal mengaktifkan {rule}: {error}",
      "config_title": "Pengaturan Konfigurasi",
      "config_description": "Konfigurasikan pengaturan untuk aturan yang diaktifkan.",
      "config_prompt": "Konfigurasikan pengaturan aturan sekarang? (yes/no):",
      "config_skip": "Konfigurasi dilewati. Anda dapat mengkonfigurasi pengaturan nanti.",
      "config_rule_title": "Mengkonfigurasi: {rule}",
      "config_memory_path_examples": "Contoh path:",
      "config_memory_path_note": "Catatan",
      "config_memory_path_prompt": "Masukkan path penyimpanan memori:",
      "config_memory_path_error_empty": "Path tidak boleh kosong.",
      "config_memory_path_create_prompt": "Path tidak ada. Buat? (yes/no):",
      "config_memory_path_create_success": "âœ“ Direktori dibuat: {path}",
      "config_memory_path_create_error": "âœ— Gagal membuat direktori: {error}",
      "config_memory_path_confirm_path": "Menggunakan path: {path}",
      "config_memory_path_confirm_structure": "Struktur direktori",
      "config_memory_path_confirm_prompt": "Gunakan path ini? (yes/no):",
      "config_memory_path_confirm_invalid": "Silakan jawab 'yes' atau 'no'.",
      "lang_option_en": "ğŸ‡ºğŸ‡¸ English",
      "lang_option_ja": "ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª",
      "lang_option_id": "ğŸ‡®ğŸ‡© Bahasa Indonesia",
      "lang_option_zh": "ğŸ‡¨ğŸ‡³ ä¸­æ–‡",
      "lang_option_ar": "ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
      "lang_option_de": "ğŸ‡©ğŸ‡ª Deutsch",
      "lang_option_fr": "ğŸ‡«ğŸ‡· FranÃ§ais",
      "lang_option_es": "ğŸ‡ªğŸ‡¸ EspaÃ±ol",
      "lang_option_ko": "ğŸ‡°ğŸ‡· í•œêµ­ì–´",
      "lang_option_hi": "ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€",
      "lang_option_pt": "ğŸ‡µğŸ‡¹ PortuguÃªs",
      "lang_option_ru": "ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹",
      "lang_option_si": "ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½",
      "lang_option_ta": "ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯",
      "lang_option_th": "ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢",
      "lang_option_tr": "ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e",
      "lang_option_vi": "ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t"
    }
  }
}`);  // ---AUTO GENERATED LOCALIZATION END---

  </script>

</head>

<body>
  <div class="container">
    <div class="header">
      <div class="header-top">
        <!-- Modern Language Selector -->
        <div class="language-selector">
          <select id="ui-language" onchange="updateUILanguage()">
            <!-- AUTO GENERATED CONTENT START -->
<option value="en">EN (en)</option>
<option value="ja">JA (ja)</option>
<option value="id">ID (id)</option>
<!-- AUTO GENERATED CONTENT END -->
          </select>
        </div>

        <!-- Server shutdown button (enhanced mode only) -->
        <div id="server-controls" style="display: none;">
          <button onclick="shutdownServer()"
            style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">
            ğŸ›‘ Stop Server
          </button>
        </div>
      </div>

      <div class="header-content">
        <h1>ğŸ¤– Agentic Rules Setup</h1>
        <p>Configure your AI agent rules with ease</p>
      </div>
    </div>

    <div class="content">
      <!-- Language Selection -->
      <div class="section">
        <h2>ğŸŒ Agent Language Settings</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
          <div class="form-group">
            <label for="agent-language">Agent Language:</label>
            <select id="agent-language" onchange="updateAgentLanguage()">
              <!-- AUTO GENERATED CONTENT START -->
<option value="en">EN (en)</option>
<option value="ja">JA (ja)</option>
<option value="id">ID (id)</option>
<!-- AUTO GENERATED CONTENT END -->
            </select>
            <div class="help-text">Language for generated agent files</div>
          </div>
          <div class="form-group">
            <label for="agent-file-type">Agent File Type:</label>
            <select id="agent-file-type" onchange="updateAgentFileType()">
              <option value="AGENTS.md">AGENTS.md</option>
              <option value="GEMINI.md">GEMINI.md</option>
              <option value="CLAUDE.md">CLAUDE.md</option>
            </select>
            <div class="help-text">Choose AGENTS.md, GEMINI.md, or CLAUDE.md format</div>
          </div>
        </div>

        <div class="help-text" style="margin-top: 15px;">
          <strong>Agent Language:</strong> Controls the language of generated agent files (AGENTS.md, GEMINI.md, or
          CLAUDE.md)
        </div>
      </div>

      <!-- Rules Selection -->
      <div class="section">
        <h2 id="rules-title">âš™ï¸ Select Rules to Activate</h2>
        <p id="rules-desc">Choose which AI behavior rules you want to enable for your agent.</p>

        <div id="rules-container">
          <div class="loading">
            <div class="loading-spinner"></div>
            <p>Loading available plugins...</p>
          </div>
        </div>
      </div>

      <!-- Configuration Options (shown inline when rules are selected) -->
      <div id="config-section" style="display: none;">
        <div class="section">
          <h2>ğŸ”§ Configuration Options</h2>
          <p>Configure settings for the selected rules below.</p>

          <div id="config-container">
            <div class="loading">
              <div class="loading-spinner"></div>
              <p>Loading configuration options...</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="section">
        <h2>ğŸš€ Generate Configuration</h2>
        <div style="display: flex; gap: 15px; margin-bottom: 20px;">
          <button class="btn" onclick="generateConfig()" id="generate-btn">Generate Configuration Files</button>
          <button class="btn" onclick="exportConfig()" id="export-btn"
            style="background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);">Export Configuration</button>
          <button class="btn" onclick="factoryReset()"
            style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);" id="reset-btn">Factory Reset</button>
        </div>

        <div class="progress-bar" id="progress-bar">
          <div class="progress-fill" id="progress-fill"></div>
        </div>

        <div class="help-text">
          <strong>How it works:</strong><br>
          â€¢ <strong>Checking rules</strong> above selects which AI behaviors to enable<br>
          â€¢ <strong>Configuration options</strong> appear below when rules are selected<br>
          â€¢ <strong>Generate button</strong> creates the actual configuration files<br>
          â€¢ <strong>Factory Reset</strong> clears all selections and configurations
        </div>
      </div>

      <!-- Results -->
      <div class="result error" id="result-error">
        <h3>âŒ Configuration Failed</h3>
        <p id="error-message">An error occurred during configuration.</p>
      </div>

      <div class="result success" id="result-success" style="display: none;">
        <div id="generated-files">
          <!-- Generated files will be displayed here -->
        </div>
      </div>
    </div>
  </div>
  <script>
    let uiLanguage = 'en';
    let agentLanguage = 'en';
    let agentFileType = 'AGENTS.md';
    let selectedRules = {};
    let pluginConfig = {};
    let generatedFiles = null; // Store generated files for re-localization

    // Storage functions with localStorage and cookie fallback
    function saveToStorage(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch (e) {
        // Fallback to cookies
        const expires = new Date();
        expires.setDate(expires.getDate() + 365); // 1 year
        document.cookie = `${key}=${encodeURIComponent(value)}; expires=${expires.toUTCString()}; path=/`;
      }
    }

    function loadFromStorage(key) {
      try {
        let value = localStorage.getItem(key);
        if (value !== null) return value;
      } catch (e) {
        // Fallback to cookies
        const name = key + "=";
        const decodedCookie = decodeURIComponent(document.cookie);
        const ca = decodedCookie.split(';');
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === ' ') c = c.substring(1);
          if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
      }
      return null;
    }

    function savePreferences() {
      saveToStorage('agentic-rules-ui-language', uiLanguage);
      saveToStorage('agentic-rules-agent-language', agentLanguage);
      saveToStorage('agentic-rules-agent-file-type', agentFileType);
      saveToStorage('agentic-rules-selected-rules', JSON.stringify(selectedRules));
    }

    function loadSavedPreferences() {
      // Load UI language
      const savedUILang = loadFromStorage('agentic-rules-ui-language');
      if (savedUILang) {
        uiLanguage = savedUILang;
      }

      // Load agent language
      const savedAgentLang = loadFromStorage('agentic-rules-agent-language');
      if (savedAgentLang) {
        agentLanguage = savedAgentLang;
      }

      // Load agent file type
      const savedFileType = loadFromStorage('agentic-rules-agent-file-type');
      if (savedFileType) {
        agentFileType = savedFileType;
      }

      // Load selected rules
      const savedRules = loadFromStorage('agentic-rules-selected-rules');
      if (savedRules) {
        try {
          selectedRules = JSON.parse(savedRules);
        } catch (e) {
          console.warn('Failed to parse saved rules:', e);
          selectedRules = {};
        }
      }

      // Load config values for each plugin (only if pluginConfig is already loaded)
      if (pluginConfig && pluginConfig.plugins) {
        // First try per-plugin storage
        for (const pluginName in pluginConfig.plugins) {
          const savedConfig = loadFromStorage(`agentic-rules-config-values-${pluginName}`);
          if (savedConfig) {
            try {
              const configValues = JSON.parse(savedConfig);
              // Store config values - will be used when generating config interface
              if (!selectedRules[pluginName]) {
                selectedRules[pluginName] = {};
              }
              if (typeof selectedRules[pluginName] === 'object') {
                Object.assign(selectedRules[pluginName], configValues);
              }
            } catch (e) {
              console.warn(`Failed to parse saved config for ${pluginName}:`, e);
            }
          }
        }

        // Fallback to global config storage (backward compatibility)
        const globalConfig = loadFromStorage('agentic-rules-config-values');
        if (globalConfig) {
          try {
            const allConfigValues = JSON.parse(globalConfig);
            for (const [pluginName, configValues] of Object.entries(allConfigValues)) {
              if (pluginConfig.plugins[pluginName]) {
                if (!selectedRules[pluginName]) {
                  selectedRules[pluginName] = {};
                }
                if (typeof selectedRules[pluginName] === 'object' && typeof configValues === 'object') {
                  Object.assign(selectedRules[pluginName], configValues);
                }
              }
            }
          } catch (e) {
            console.warn('Failed to parse global saved config:', e);
          }
        }
      }
    }

    function saveConfigValue(inputId, value) {
      // Parse input ID to get plugin and config name
      const parts = inputId.split('-');
      if (parts.length < 3) return;

      const pluginName = parts[0];
      const configName = parts[1];
      const optionName = parts.length > 3 ? parts.slice(2).join('-') : null;

      // Store in selectedRules structure
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      if (optionName) {
        // For checkbox options
        if (!selectedRules[pluginName][configName]) {
          selectedRules[pluginName][configName] = {};
        }
        selectedRules[pluginName][configName][optionName] = value;
      } else {
        // For text inputs
        selectedRules[pluginName][configName] = value;
      }

      // Save to storage (per-plugin)
      saveToStorage(`agentic-rules-config-values-${pluginName}`, JSON.stringify(selectedRules[pluginName]));

      // Also save global config values (for backward compatibility)
      const allConfigValues = {};
      for (const [pn, ruleData] of Object.entries(selectedRules)) {
        if (typeof ruleData === 'object' && ruleData !== null && !Array.isArray(ruleData)) {
          // Check if this rule has config values (not just boolean)
          const hasConfig = Object.keys(ruleData).length > 0 && Object.values(ruleData).some(v => typeof v !== 'boolean');
          if (hasConfig) {
            allConfigValues[pn] = ruleData;
          }
        }
      }
      if (Object.keys(allConfigValues).length > 0) {
        saveToStorage('agentic-rules-config-values', JSON.stringify(allConfigValues));
      }

      // Also save all preferences
      savePreferences();
    }

    function applySavedConfigValues(configValues) {
      // Apply saved config values to form inputs
      for (const [pluginName, pluginConfig] of Object.entries(configValues)) {
        for (const [configName, configValue] of Object.entries(pluginConfig)) {
          if (typeof configValue === 'object') {
            // Handle checkbox options
            for (const [optionName, optionValue] of Object.entries(configValue)) {
              const checkbox = document.getElementById(`${pluginName}-${configName}-${optionName}`);
              if (checkbox) {
                checkbox.checked = optionValue;
              }
            }
          } else {
            // Handle text inputs
            const input = document.getElementById(`${pluginName}-${configName}-input`);
            if (input) {
              input.value = configValue;
            }
          }
        }
      }
    }

    // Check for enhanced mode (full file access) vs regular mode
    let isEnhancedMode = false;

    function checkEnhancedMode() {
      // Check if running with enhanced access (localhost with API access)
      isEnhancedMode = window.location.hostname === 'localhost' ||
        window.location.hostname === '127.0.0.1' ||
        window.location.protocol === 'http:' || window.location.protocol === 'https:';
      return isEnhancedMode;
    }

    // Load configuration on page load
    window.onload = function () {
      // Check if running in enhanced mode
      isEnhancedMode = checkEnhancedMode();

      // Show server controls if in enhanced mode
      if (isEnhancedMode) {
        const serverControls = document.getElementById('server-controls');
        if (serverControls) {
          serverControls.style.display = 'block';
        }
      }

      // Configuration is embedded directly in HTML
      pluginConfig = staticWebConfig;

      // Load saved preferences first
      loadSavedPreferences();

      // uiLanguage and agentLanguage are already set in loadSavedPreferences()

      // Clean up selectedRules to only contain valid plugins, then initialize
      const validPluginNames = Object.keys(pluginConfig.plugins);
      const cleanedSelectedRules = {};
      for (const pluginName of validPluginNames) {
        // Keep existing selections for valid plugins, default to false for new ones
        cleanedSelectedRules[pluginName] = selectedRules[pluginName] || false;
      }
      selectedRules = cleanedSelectedRules;

      // Set language selectors
      document.getElementById('ui-language').value = uiLanguage;
      document.getElementById('agent-language').value = agentLanguage;
      document.getElementById('agent-file-type').value = agentFileType;

      generateRulesInterface();
      updateUILanguage();
      updateInterfaceLanguage();

      // Check if any rules are selected and show config interface
      // A rule is selected if it's truthy (true or an object with config values)
      const hasSelectedRules = Object.values(selectedRules).some(selected => selected === true || (typeof selected === 'object' && selected !== null));
      if (hasSelectedRules) {
        // Show the config section
        document.getElementById('config-section').style.display = 'block';
        // Generate config interface
        generateConfigInterface();
        // Re-apply saved config values after generating the interface
        const savedConfig = loadFromStorage('agentic-rules-config-values');
        if (savedConfig) {
          try {
            applySavedConfigValues(JSON.parse(savedConfig));
          } catch (e) {
            console.warn('Failed to reapply saved config values:', e);
          }
        }
        // Also try per-plugin config values
        for (const [pluginName, pluginData] of Object.entries(pluginConfig.plugins)) {
          if (selectedRules[pluginName]) {
            const savedPluginConfig = loadFromStorage(`agentic-rules-config-values-${pluginName}`);
            if (savedPluginConfig) {
              try {
                const configValues = JSON.parse(savedPluginConfig);
                // Apply to form inputs
                for (const [configName, configValue] of Object.entries(configValues)) {
                  if (typeof configValue === 'object') {
                    // Handle checkbox options
                    for (const [optionName, optionValue] of Object.entries(configValue)) {
                      const checkbox = document.getElementById(`${pluginName}-${configName}-${optionName}`);
                      if (checkbox) {
                        checkbox.checked = optionValue;
                      }
                    }
                  } else {
                    // Handle text inputs
                    const input = document.getElementById(`${pluginName}-${configName}-input`);
                    if (input) {
                      input.value = configValue;
                    }
                  }
                }
              } catch (e) {
                console.warn(`Failed to parse saved config for ${pluginName}:`, e);
              }
            }
          }
        }
      } else {
        // Hide config section if no rules selected
        document.getElementById('config-section').style.display = 'none';
      }

      // Show success message if preferences were loaded
      const hasSavedPrefs = loadFromStorage('agentic-rules-ui-language') ||
        loadFromStorage('agentic-rules-selected-rules');
      if (hasSavedPrefs) {
        const strings = localization[uiLanguage] || localization['en'];
        showStatusMessage(strings.status.restored, 'success');
      }

      console.log('âœ… Loaded static configuration with', Object.keys(pluginConfig.plugins).length, 'plugins');
      console.log('âœ… Loaded saved preferences - UI:', uiLanguage, 'Agent:', agentLanguage);

      // Debug: Check storage status
      console.log('ğŸ” Storage debug:');
      console.log('  - UI Language saved:', loadFromStorage('agentic-rules-ui-language'));
      console.log('  - Agent Language saved:', loadFromStorage('agentic-rules-agent-language'));
      console.log('  - Agent File Type saved:', loadFromStorage('agentic-rules-agent-file-type'));
      console.log('  - Selected rules saved:', loadFromStorage('agentic-rules-selected-rules'));

      // Debug: Check what storage mechanisms are working
      try {
        localStorage.setItem('test-key', 'test-value');
        const testValue = localStorage.getItem('test-key');
        console.log('âœ… localStorage working:', testValue === 'test-value');
        localStorage.removeItem('test-key');
      } catch (e) {
        console.warn('âŒ localStorage not working:', e.message);
      }

      try {
        document.cookie = 'test-cookie=test-value; path=/';
        const hasCookie = document.cookie.includes('test-cookie');
        console.log('âœ… Cookies working:', hasCookie);
        // Clean up test cookie
        document.cookie = 'test-cookie=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/';
      } catch (e) {
        console.warn('âŒ Cookies not working:', e.message);
      }
    }


    function updateUILanguage() {
      uiLanguage = document.getElementById('ui-language').value;

      // Save preference
      savePreferences();

      // Update interface text when UI language changes
      updateInterfaceLanguage();

      // Regenerate rules interface to update plugin names/descriptions
      generateRulesInterface();

      // Regenerate config interface if any rules are selected
      const hasSelectedRules = Object.values(selectedRules).some(selected => selected);
      if (hasSelectedRules) {
        generateConfigInterface();
        // Re-apply saved config values after regenerating the interface
        const savedConfig = loadFromStorage('agentic-rules-config-values');
        if (savedConfig) {
          try {
            applySavedConfigValues(JSON.parse(savedConfig));
          } catch (e) {
            console.warn('Failed to reapply saved config values:', e);
          }
        }
      }
    }

    function updateAgentLanguage() {
      agentLanguage = document.getElementById('agent-language').value;

      // Save preference
      savePreferences();
    }

    function updateAgentFileType() {
      agentFileType = document.getElementById('agent-file-type').value;

      // Save preference
      savePreferences();

      // Agent language affects template selection, but doesn't change UI immediately
      // The templates will be selected when generating files
    }

    function updateInterfaceLanguage() {
      const strings = localization[uiLanguage] || localization['en'];

      // Update header
      const headerTitle = document.querySelector('.header h1');
      const headerDesc = document.querySelector('.header p');

      if (headerTitle) headerTitle.textContent = strings.header.title;
      if (headerDesc) headerDesc.textContent = strings.header.description;

      // Update language section
      const agentLangLabel = document.querySelector('label[for="agent-language"]');
      const agentLangHelp = document.querySelector('select[id="agent-language"]').nextElementSibling;
      const agentFileTypeLabel = document.querySelector('label[for="agent-file-type"]');
      const agentFileTypeHelp = document.querySelector('select[id="agent-file-type"]').nextElementSibling;
      const langHelpText = document.querySelector('div.help-text[style*="margin-top"]');

      if (agentLangLabel) agentLangLabel.innerHTML = strings.language.agentLabel;
      if (agentLangHelp) agentLangHelp.textContent = strings.language.agentHelp;
      if (agentFileTypeLabel) agentFileTypeLabel.innerHTML = strings.language.fileTypeLabel;
      if (agentFileTypeHelp) agentFileTypeHelp.textContent = strings.language.fileTypeHelp;
      if (langHelpText) langHelpText.innerHTML = strings.language.helpText;

      // Update rules section
      const rulesTitle = document.getElementById('rules-title');
      const rulesDesc = document.getElementById('rules-desc');

      if (rulesTitle) rulesTitle.textContent = strings.rules.title;
      if (rulesDesc) rulesDesc.textContent = strings.rules.description;

      // Update configuration section
      const configTitle = document.querySelector('#config-section h2');
      const configDesc = document.querySelector('#config-section p');

      if (configTitle) configTitle.textContent = strings.config.title;
      if (configDesc) configDesc.textContent = strings.config.description;

      // Update action section
      const actionTitle = document.querySelector('#config-section + .section h2');
      const generateBtn = document.getElementById('generate-btn');
      const resetBtn = document.getElementById('reset-btn');

      if (actionTitle) actionTitle.textContent = strings.action.title;
      if (generateBtn) generateBtn.textContent = strings.action.generateBtn;
      if (resetBtn) resetBtn.textContent = strings.action.resetBtn;

      // Update "How it works" section specifically
      const helpTextDiv = document.querySelector('#config-section + .section .help-text');
      if (helpTextDiv) {
        helpTextDiv.innerHTML = strings.howItWorks;
      }

      // Re-localize generated files results if they exist
      if (generatedFiles && document.getElementById('result-success').style.display !== 'none') {
        showGeneratedFiles(generatedFiles);
      }

    }

    function toggleRule(rule) {
      selectedRules[rule] = document.getElementById(`${rule}-enabled`).checked;

      // Save preferences
      savePreferences();

      // Show/hide configuration section based on whether any rules are selected
      const hasSelectedRules = Object.values(selectedRules).some(selected => selected);
      document.getElementById('config-section').style.display = hasSelectedRules ? 'block' : 'none';

      // Regenerate config interface when rules change
      if (hasSelectedRules) {
        generateConfigInterface();
        // Re-apply saved config values after regenerating the interface
        const savedConfig = loadFromStorage('agentic-rules-config-values');
        if (savedConfig) {
          try {
            applySavedConfigValues(JSON.parse(savedConfig));
          } catch (e) {
            console.warn('Failed to reapply saved config values:', e);
          }
        }
      }
    }

    function exportConfig() {
      // Export current configuration to a JSON file for use with setup.py
      const config = {
        "_metadata": {
          "exported_from": "setup.html",
          "export_timestamp": new Date().toISOString(),
          "version": "0.1.0"
        },
        "ui_language": uiLanguage,
        "agent_language": agentLanguage,
        "agent_file_type": agentFileType,
        "selected_rules": selectedRules
      };

      const configJson = JSON.stringify(config, null, 2);
      const filename = 'agentic-rules-config.json';

      // Create download link
      const blob = new Blob([configJson], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      // Show success message
      const resultDiv = document.getElementById('result-success');
      if (resultDiv) {
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `
          <h3>âœ… Configuration Exported!</h3>
          <p>Configuration file <code>${filename}</code> has been downloaded.</p>
          <p>You can use this file with <code>setup.py</code> by placing it in your project directory.</p>
          <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
            <strong>Usage:</strong><br>
            <code>python setup.py --config agentic-rules-config.json</code>
          </div>
        `;
      }
    }

    function factoryReset() {
      // Clear any previously generated files
      generatedFiles = null;

      // Reset language to English
      uiLanguage = 'en';
      agentLanguage = 'en';
      agentFileType = 'AGENTS.md';
      document.getElementById('ui-language').value = 'en';
      document.getElementById('agent-language').value = 'en';
      document.getElementById('agent-file-type').value = 'AGENTS.md';
      updateInterfaceLanguage();

      // Reset all rule checkboxes
      for (const rule in selectedRules) {
        selectedRules[rule] = false;
        const checkbox = document.getElementById(`${rule}-enabled`);
        if (checkbox) checkbox.checked = false;
      }

      // Clear all saved preferences from both localStorage and cookies
      // Clear specific known keys first
      const knownKeys = [
        'agentic-rules-ui-language',
        'agentic-rules-agent-language',
        'agentic-rules-agent-file-type',
        'agentic-rules-selected-rules',
        'agentic-rules-config-values'
      ];

      for (const key of knownKeys) {
        try {
          localStorage.removeItem(key);
        } catch (e) {
          // localStorage failed, continue
        }

        // Clear cookie by setting expired date
        try {
          document.cookie = `${key}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
        } catch (e) {
          // Cookie clearing failed, continue
        }
      }

      // Clear all agentic-rules prefixed keys (including per-plugin config keys)
      try {
        const allKeys = Object.keys(localStorage);
        for (const key of allKeys) {
          if (key.startsWith('agentic-rules-')) {
            localStorage.removeItem(key);
          }
        }
      } catch (e) {
        // localStorage access failed, continue
      }

      // Clear all agentic-rules prefixed cookies
      try {
        const cookies = document.cookie.split(';');
        for (const cookie of cookies) {
          const cookieName = cookie.split('=')[0].trim();
          if (cookieName.startsWith('agentic-rules-')) {
            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
          }
        }
      } catch (e) {
        // Cookie access failed, continue
      }

      console.log('âœ… Cleared all saved preferences from localStorage and cookies');

      // Hide config section
      document.getElementById('config-section').style.display = 'none';

      // Clear config container
      document.getElementById('config-container').innerHTML = '';

      // Hide results
      document.getElementById('result-error').style.display = 'none';

      // Reset progress bar
      document.getElementById('progress-bar').style.display = 'none';
      document.getElementById('progress-fill').style.width = '0%';

      console.log('Factory reset completed');
    }

    function generateRulesInterface() {
      const container = document.getElementById('rules-container');
      if (!container) {
        console.error('âŒ Rules container not found!');
        return;
      }
      container.innerHTML = '';

      for (const [pluginName, pluginData] of Object.entries(pluginConfig.plugins)) {
        // Get localized name and description based on UI language
        const pluginLocalization = pluginData.localization || {};
        let langData = pluginLocalization[uiLanguage];

        // If requested language not available, fall back to plugin's native language
        if (!langData) {
          // Try any available language from the plugin's localization
          const availableLangs = Object.keys(pluginLocalization);
          if (availableLangs.length > 0) {
            // Use the first available language (plugin's native language)
            langData = pluginLocalization[availableLangs[0]];
          }
        }

        // Final fallback to plugin metadata or raw name
        const displayName = (langData && langData.plugin_name) || pluginData.display_name || pluginName;
        const description = (langData && langData.description) || pluginData.description || '';

        const ruleCard = document.createElement('div');
        ruleCard.className = 'rule-card';

        // Get localized enable text
        const strings = localization[uiLanguage] || localization['en'];
        const enableText = strings.rules.enable;

        const isChecked = selectedRules[pluginName] || false;

        ruleCard.innerHTML = `
                    <h3>${getPluginIcon(pluginName)} ${displayName}</h3>
                    <p>${description}</p>
                    <div class="rule-toggle">
                        <input type="checkbox" id="${pluginName}-enabled" onchange="toggleRule('${pluginName}')" ${isChecked ? 'checked' : ''}>
                        <label for="${pluginName}-enabled">${enableText} ${displayName}</label>
                    </div>
                `;

        container.appendChild(ruleCard);
      }
    }

    function generateConfigInterface() {
      const container = document.getElementById('config-container');
      container.innerHTML = '';

      // Add mandatory configs first
      for (const [pluginName, pluginData] of Object.entries(pluginConfig.plugins)) {
        if (!selectedRules[pluginName]) continue;

        // Check if plugin has multiple language templates
        const availablePluginLanguages = Object.keys(pluginData.templates || {});
        const hasMultipleLanguages = availablePluginLanguages.length > 1;

        // Add language selector for plugins with multiple languages
        if (hasMultipleLanguages) {
          const langSection = generateLanguageSection(pluginName, availablePluginLanguages);
          container.appendChild(langSection);
        }

        // Mandatory configs
        for (const config of pluginData.mandatory_config || []) {
          const configSection = generateConfigSection(pluginName, config, true);
          container.appendChild(configSection);
        }

        // Optional configs
        for (const config of pluginData.optional_config || []) {
          const configSection = generateConfigSection(pluginName, config, false);
          container.appendChild(configSection);
        }
      }
    }

    function generateConfigSection(pluginName, config, isMandatory) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-${config.name}-config`;

      const configLocalization = config.localization || {};
      const langData = configLocalization[uiLanguage] || configLocalization['en'] || {};
      const title = langData.title || config.title || config.name;
      const description = langData.description || config.description || '';

      let content = `<h2>${getPluginIcon(pluginName)} ${title}</h2>`;

      if (description) {
        content += `<p>${description}</p>`;
      }

      if (config.type === 'path') {
        const examples = langData.examples || config.examples || [];
        const note = langData.note || config.note || '';

        content += `
                    <div class="form-group">
                        <label for="${pluginName}-${config.name}-input">${title} ${isMandatory ? '<span class="required">*</span>' : ''}</label>
                        <input type="text" id="${pluginName}-${config.name}-input" placeholder="${examples[0] || ''}" oninput="saveConfigValue('${pluginName}-${config.name}-input', this.value)">
                        <div class="help-text">${examples.length > 0 ? 'Examples: ' + examples.join(', ') : ''}</div>
                        ${note ? `<div class="help-text">${note}</div>` : ''}
                    </div>
                `;
      } else if (config.type === 'choice') {
        content += '<div class="form-group">';

        for (const option of config.options || []) {
          const optionLocalization = option.localization || {};
          const optionLangData = optionLocalization[uiLanguage] || optionLocalization['en'] || {};
          const optionDesc = optionLangData.description || option.description || option.name;
          const strings = localization[uiLanguage] || localization['en'];
          const recommended = option.recommended ? (strings.cli ? strings.cli.recommended_text : ' (Recommended)') : '';

          content += `
                        <div class="checkbox-group">
                            <input type="checkbox" id="${pluginName}-${config.name}-${option.name}" ${option.recommended ? 'checked' : ''} onchange="saveConfigValue('${pluginName}-${config.name}-${option.name}', this.checked)">
                            <label for="${pluginName}-${config.name}-${option.name}">${option.name}: ${optionDesc}${recommended}</label>
                        </div>
                    `;
        }

        content += '</div>';
      }

      section.innerHTML = content;
      return section;
    }

    function getPluginIcon(pluginName) {
      const icons = {
        'memory-rules': 'ğŸ§ ',
        'rag-rules': 'ğŸ“š',
        'critical-thinking-rules': 'ğŸ¤”'
      };
      return icons[pluginName] || 'âš™ï¸';
    }

    function showError(message) {
      const container = document.getElementById('rules-container');
      container.innerHTML = `
                <div class="section" style="background: #fee; border-color: #fcc;">
                    <h2 style="color: #c33;">Error</h2>
                    <p>${message}</p>
                </div>
            `;
    }

    async function generateConfig() {
      const generateBtn = document.getElementById('generate-btn');
      const progressBar = document.getElementById('progress-bar');
      const progressFill = document.getElementById('progress-fill');

      // Hide any previous results
      document.getElementById('result-error').style.display = 'none';
      document.getElementById('result-success').style.display = 'none';

      generateBtn.disabled = true;
      const strings = localization[uiLanguage] || localization['en'];
      generateBtn.textContent = strings.action.generating;
      progressBar.style.display = 'block';

      try {
        // Simulate progress
        progressFill.style.width = '25%';

        // Generate configuration based on selections
        // Ensure selectedRules only contains valid plugins
        const validPluginNames = Object.keys(pluginConfig.plugins);
        const cleanRules = {};
        for (const pluginName of validPluginNames) {
          cleanRules[pluginName] = selectedRules[pluginName] || false;
        }

        const config = {
          uiLanguage: uiLanguage,
          agentLanguage: agentLanguage,
          agentFileType: agentFileType,
          language: agentLanguage, // For backward compatibility
          rules: cleanRules,
          settings: {}
        };

        // Collect settings for each enabled rule
        if (!pluginConfig || !pluginConfig.plugins) {
          throw new Error('Plugin configuration not loaded. Please refresh the page.');
        }

        for (const [pluginName, pluginData] of Object.entries(pluginConfig.plugins)) {
          if (!selectedRules[pluginName]) continue;

          config.settings[pluginName] = {};

          // Handle mandatory configs
          for (const mandatoryConfig of pluginData.mandatory_config || []) {
            const inputElement = document.getElementById(`${pluginName}-${mandatoryConfig.name}-input`);
            if (inputElement) {
              // Use settings_key to map to correct location, fallback to config name
              const settingsKey = mandatoryConfig.settings_key || mandatoryConfig.name;
              setNestedValue(config.settings[pluginName], settingsKey, inputElement.value || '');
            }
          }

          // Handle optional configs
          for (const optionalConfig of pluginData.optional_config || []) {
            // Check which options are selected
            for (const option of optionalConfig.options || []) {
              const checkbox = document.getElementById(`${pluginName}-${optionalConfig.name}-${option.name}`);
              if (checkbox && checkbox.checked) {
                // Apply the settings from the selected option
                if (option.settings) {
                  config.settings[pluginName] = {
                    ...config.settings[pluginName],
                    ...option.settings
                  };
                }
              }
            }
          }
        }

        progressFill.style.width = '50%';

        // Generate the files
        await generateFiles(config);

        progressFill.style.width = '100%';

        // Configuration completed successfully

      } catch (error) {
        console.error('Configuration failed:', error);
        const errorDiv = document.getElementById('result-error');
        const errorMessageDiv = document.getElementById('error-message');
        if (errorDiv) {
          errorDiv.style.display = 'block';
        }
        if (errorMessageDiv) {
          errorMessageDiv.textContent = error.message;
        }
      } finally {
        generateBtn.disabled = false;
        const strings = localization[uiLanguage] || localization['en'];
        generateBtn.textContent = strings.action.generateBtn;
        setTimeout(() => {
          progressBar.style.display = 'none';
          progressFill.style.width = '0%';
        }, 1000);
      }
    }

    async function generateFiles(config) {
      const fileContents = {};

      // Clean up conflicting files first (enhanced mode only)
      if (isEnhancedMode && config.agentFileType) {
        try {
          console.log('Cleaning up conflicting files...');
          const cleanupResponse = await fetch('/api/cleanup-files', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              keep_file: config.agentFileType
            })
          });

          if (cleanupResponse.ok) {
            const result = await cleanupResponse.json();
            if (result.cleaned_files && result.cleaned_files.length > 0) {
              console.log(`Cleaned up ${result.cleaned_files.length} conflicting files:`, result.cleaned_files);
            }
          }
        } catch (err) {
          console.warn('Cleanup failed, continuing anyway:', err);
        }
      }

      // Generate main AGENTS.md or GEMINI.md file
      if (Object.values(config.rules).some(enabled => enabled)) {
        const agentsContent = generateAgentsFile(config);
        fileContents[config.agentFileType] = agentsContent;
      }

      // Generate rule-specific agent files from templates
      for (const [rule, enabled] of Object.entries(config.rules)) {
        if (enabled) {
          const ruleContent = generateRuleAgentsFileFromTemplate(rule, config);
          fileContents[`${rule}/${config.agentFileType}`] = ruleContent;
        }
      }

      // Generate settings.json files
      for (const [rule, enabled] of Object.entries(config.rules)) {
        if (enabled) {
          const settingsContent = generateSettingsFile(rule, config);
          fileContents[`${rule}/settings.json`] = settingsContent;
        }
      }

      // Show results with copy-paste interface
      showGeneratedFiles(fileContents);
    }

    function showGeneratedFiles(files) {
      // Store files for potential re-localization
      generatedFiles = files;

      // Hide error result and show success result
      const errorDiv = document.getElementById('result-error');
      const successDiv = document.getElementById('result-success');
      const generatedFilesDiv = document.getElementById('generated-files');

      if (!errorDiv || !successDiv || !generatedFilesDiv) {
        console.error('Required DOM elements not found for showing generated files');
        return;
      }

      errorDiv.style.display = 'none';
      successDiv.style.display = 'block';

      // Get localized strings
      const strings = localization[uiLanguage] || localization['en'];
      const fg = strings.fileGeneration;

      let html = `
                <div style="padding: 20px;">
                    <h3 style="color: #2e7d32; margin-bottom: 20px;">${fg.title}</h3>
                    <p>${fg.subtitle}</p>
            `;

      for (const [filename, content] of Object.entries(files)) {
        html += `
                    <div style="margin: 20px 0; border: 1px solid #ddd; border-radius: 8px;">
                        <div style="background: #f8f9fa; padding: 10px 15px; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center;">
                            <strong style="color: #2c3e50;">${filename}</strong>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="copyToClipboard('${filename.replace(/'/g, "\\'")}', this)" style="background: #007bff; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">
                                    ${fg.copyButton}
                                </button>
                                <button onclick="saveFile('${filename.replace(/'/g, "\\'")}', this)" style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;" title="Save file to chosen location">
                                    ${fg.saveButton}
                                </button>
                                <button onclick="downloadFile('${filename.replace(/'/g, "\\'")}', this)" style="background: #6f42c1; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;" title="Download to Downloads folder">
                                    ${fg.downloadButton}
                                </button>
                                ${isEnhancedMode ? `<button onclick="createFile('${filename.replace(/'/g, "\\'")}', this)" style="background: #17a2b8; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;" title="Create file directly">
                                    ${fg.createButton}
                                </button>` : ''}
                            </div>
                        </div>
                        <div style="padding: 15px; background: #f8f9fa;">
                            <textarea id="content-${filename.replace(/[^a-zA-Z0-9]/g, '-')}" readonly style="width: 100%; height: 200px; font-family: monospace; font-size: 12px; border: 1px solid #ccc; border-radius: 4px; padding: 10px; resize: vertical;">${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                        </div>
                    </div>
                `;
      }

      // Build file tree dynamically from actual generated files
      let treeLines = [`<strong>${fg.projectRoot}</strong><br>`, 'ğŸ“ your-project/<br>'];

      // Find root file (AGENTS.md or GEMINI.md)
      const rootFiles = Object.keys(files).filter(f => !f.includes('/')).sort();

      // Group files by directory
      const dirs = {};
      Object.keys(files).forEach(filename => {
        if (filename.includes('/')) {
          const [dir, file] = filename.split('/', 2);
          if (!dirs[dir]) {
            dirs[dir] = [];
          }
          dirs[dir].push(file);
        }
      });

      const dirNames = Object.keys(dirs).sort();
      const hasDirs = dirNames.length > 0;

      // Add root files
      rootFiles.forEach((file, index) => {
        const isLastRoot = index === rootFiles.length - 1 && !hasDirs;
        const prefix = isLastRoot ? 'â””â”€â”€' : 'â”œâ”€â”€';
        treeLines.push(`${prefix} ğŸ“„ ${file}<br>`);
      });

      // Build tree for each directory
      dirNames.forEach((dir, dirIndex) => {
        const isLastDir = dirIndex === dirNames.length - 1;
        const dirPrefix = isLastDir ? 'â””â”€â”€' : 'â”œâ”€â”€';
        treeLines.push(`${dirPrefix} ğŸ“ ${dir}/<br>`);

        const filesInDir = dirs[dir].sort();
        filesInDir.forEach((file, fileIndex) => {
          const isLastFile = fileIndex === filesInDir.length - 1;
          const filePrefix = isLastDir && isLastFile ? '    â””â”€â”€' : 'â”‚   â”œâ”€â”€';
          treeLines.push(`${filePrefix} ğŸ“„ ${file}<br>`);
        });
      });

      html += `
                <div style="background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 6px; padding: 15px; margin-top: 20px;">
                    <h4 style="margin: 0 0 10px 0; color: #0c5460;">${fg.locationsTitle}</h4>
                    <div style="font-family: monospace; font-size: 14px; color: #0c5460; background: #f8f9fa; padding: 10px; border-radius: 4px;">
                        ${treeLines.join('')}
                    </div>
                    <p style="margin: 10px 0 0 0; color: #0c5460;">
                        <strong>${fg.stepsTitle}</strong><br>
                        ${fg.step1}<br>
                        ${fg.step2}<br>
                        ${fg.step3}
                    </p>
                </div>
                </div>
            `;

      generatedFilesDiv.innerHTML = html;
    }

    function generateAgentsFile(config) {
      // Use agentLanguage instead of language
      const lang = config.agentLanguage || config.language || 'en';

      // Get root template from static config
      const rootTemplates = staticWebConfig.rootTemplates || {};
      let templateContent = rootTemplates[lang] || rootTemplates['en'];

      // Fallback to hardcoded template if not found in config
      if (!templateContent) {
        const enabledRules = Object.entries(config.rules)
          .filter(([_, enabled]) => enabled)
          .map(([rule, _]) => rule);

        templateContent = `# Agent Integration Template

**MANDATORY**: Read Bootstrap.md first for framework compliance and orchestration requirements.

## Integration Architecture
This framework uses **distributed integration** - each enabled rule has its own AGENTS.md that agents MUST read and implement directly:

${enabledRules.map(rule => `- \`${rule}/AGENTS.md\` - ${getRuleDescription(rule, lang)}`).join('\n')}

## Framework Integration Process

**Algorithm: Framework_Integration_Process**
- **Input**: framework_path (path to agentic-rules directory)
- **Output**: fully_integrated_agent_system

**Steps**:
1. Execute Framework_Bootstrap_Initialization algorithm from Bootstrap.md (MANDATORY)
2. Load and validate bootstrap.json configuration
3. For each enabled rule in settings:
   - Read the rule's AGENTS.md file
   - Implement ALL algorithms specified in that file
   - Respect rule-specific settings and priorities
4. Initialize rule interconnections as defined in bootstrap.json
5. Apply platform-specific adaptations
6. Return integrated agent system with all rule algorithms active

## Critical Requirements
- **Direct Rule Implementation**: Agents MUST read and implement each enabled rule's AGENTS.md
- **No Shortcuts**: Cannot claim integration without implementing all algorithms
- **Settings Respect**: Each rule's settings.json controls enable/disable state
- **Priority Coordination**: Main agent orchestrates rule priorities across sub-agents

**Reference**: Bootstrap.md contains orchestration requirements. Individual rule AGENTS.md files contain implementation algorithms.

<!-- Copyright (c) 2025 Paulus Ery Wasito Adhi. Licensed under the MIT License (see LICENSE file). -->`;
      }

      return templateContent;
    }

    function generateRuleAgentsFileFromTemplate(rule, config) {
      // Get the plugin data from static config
      const pluginData = pluginConfig.plugins[rule];
      if (!pluginData) {
        return `# ${rule} Agent Integration\n\n**Error**: Plugin configuration not found.`;
      }

      // Get template content for the selected language
      // First check for plugin-specific language selection, then fall back to global agent language
      const pluginLanguage = selectedRules[rule]?.language || config.agentLanguage || 'en';
      const templates = pluginData.templates || {};
      const templateContent = templates[pluginLanguage] || templates['en'];

      if (!templateContent) {
        return `# ${rule} Agent Integration\n\n**Error**: Template not found for language: ${pluginLanguage}`;
      }

      return templateContent;
    }

    function generateSettingsFile(rule, config) {
      // Get plugin configuration to access default settings
      const pluginData = pluginConfig.plugins[rule];
      let settings = {};

      // Start with default settings if available
      if (pluginData && pluginData.default_settings) {
        settings = JSON.parse(JSON.stringify(pluginData.default_settings)); // Deep copy
      }

      // Merge with user-configured settings
      if (config.settings && config.settings[rule]) {
        // Deep merge user settings into defaults
        deepMerge(settings, config.settings[rule]);
      }

      return JSON.stringify(settings, null, 2);
    }

    function deepMerge(target, source) {
      for (const key in source) {
        if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
          if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key])) {
            target[key] = {};
          }
          deepMerge(target[key], source[key]);
        } else {
          target[key] = source[key];
        }
      }
      return target;
    }

    function setNestedValue(obj, path, value) {
      const keys = path.split('.');
      let current = obj;
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (!current[key] || typeof current[key] !== 'object' || Array.isArray(current[key])) {
          current[key] = {};
        }
        current = current[key];
      }
      current[keys[keys.length - 1]] = value;
    }

    function getRuleDescription(rule, lang) {
      const strings = localization[lang] || localization['en'];
      return strings.descriptions[rule] || `${rule} algorithms`;
    }

    async function downloadFile(filename, content) {
      // In a real implementation, this would create actual files
      // For the web version, we'll simulate file creation
      console.log(`Would create file: ${filename}`);
      console.log(`Content length: ${content.length} characters`);

      // Simulate async operation
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    function copyToClipboard(filename, buttonElement) {
      const textarea = document.getElementById(`content-${filename.replace(/[^a-zA-Z0-9]/g, '-')}`);
      textarea.select();
      document.execCommand('copy');

      // Visual feedback - use localized text
      const strings = localization[uiLanguage] || localization['en'];
      const originalText = buttonElement.textContent;
      buttonElement.textContent = strings.fileGeneration.copied;
      buttonElement.style.background = '#28a745';

      setTimeout(() => {
        buttonElement.textContent = originalText;
        buttonElement.style.background = '#007bff';
      }, 2000);
    }

    async function saveFile(filename, buttonElement) {
      const textarea = document.getElementById(`content-${filename.replace(/[^a-zA-Z0-9]/g, '-')}`);
      const content = textarea.value;
      const originalText = buttonElement.textContent;
      const strings = localization[uiLanguage] || localization['en'];

      try {
        // Try modern File System Access API first for proper save dialog
        if ('showSaveFilePicker' in window) {
          const options = {
            suggestedName: filename,
            startIn: 'documents', // Start in Documents folder for easier access to projects
            types: [{
              description: 'Markdown/Text Files',
              accept: { 'text/plain': ['.md', '.txt'], 'application/json': ['.json'] }
            }]
          };

          const fileHandle = await window.showSaveFilePicker(options);
          const writable = await fileHandle.createWritable();
          await writable.write(content);
          await writable.close();

          buttonElement.textContent = strings.fileGeneration.saved;
          buttonElement.style.background = '#28a745';
          setTimeout(() => {
            buttonElement.textContent = originalText;
            buttonElement.style.background = '#28a745';
          }, 3000);
        } else {
          // Fallback: Traditional download approach
          const blob = new Blob([content], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          buttonElement.textContent = 'âœ… Downloaded!';
          buttonElement.style.background = '#28a745';
          setTimeout(() => {
            buttonElement.textContent = originalText;
            buttonElement.style.background = '#28a745';
          }, 3000);
        }

      } catch (err) {
        if (err.name === 'AbortError') {
          // User cancelled the save dialog
          buttonElement.textContent = 'âŒ Cancelled';
          buttonElement.style.background = '#ffc107';
        } else {
          console.error('File save failed:', err);
          buttonElement.textContent = 'âŒ Failed';
          buttonElement.style.background = '#dc3545';
        }
        setTimeout(() => {
          buttonElement.textContent = originalText;
          buttonElement.style.background = '#28a745';
        }, 3000);
      }
    }

    async function downloadFile(filename, buttonElement) {
      const textarea = document.getElementById(`content-${filename.replace(/[^a-zA-Z0-9]/g, '-')}`);
      const content = textarea.value;
      const originalText = buttonElement.textContent;
      const strings = localization[uiLanguage] || localization['en'];

      try {
        // Traditional download to Downloads folder
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        buttonElement.textContent = strings.fileGeneration.downloaded;
        buttonElement.style.background = '#6f42c1';
        setTimeout(() => {
          buttonElement.textContent = originalText;
          buttonElement.style.background = '#6f42c1';
        }, 3000);

      } catch (err) {
        console.error('File download failed:', err);
        buttonElement.textContent = 'âŒ Failed';
        buttonElement.style.background = '#dc3545';
        setTimeout(() => {
          buttonElement.textContent = originalText;
          buttonElement.style.background = '#6f42c1';
        }, 3000);
      }
    }

    async function createFile(filename, buttonElement) {
      const textarea = document.getElementById(`content-${filename.replace(/[^a-zA-Z0-9]/g, '-')}`);
      const content = textarea.value;
      const originalText = buttonElement.textContent;

      try {
        // Server mode only: Use API to create file directly
        buttonElement.textContent = 'ğŸ’¾ Creating...';
        const response = await fetch('/api/create-file', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filename: filename,
            content: content
          })
        });

        if (response.ok) {
          const result = await response.json();
          if (result.success) {
            buttonElement.textContent = 'âœ… Created!';
            buttonElement.style.background = '#28a745';
            setTimeout(() => {
              buttonElement.textContent = originalText;
              buttonElement.style.background = '#17a2b8';
            }, 3000);
          } else {
            throw new Error(result.message || 'Creation failed');
          }
        } else {
          throw new Error(`Server error: ${response.status}`);
        }

      } catch (err) {
        console.error('File creation failed:', err);
        buttonElement.textContent = 'âŒ Failed';
        buttonElement.style.background = '#dc3545';
        setTimeout(() => {
          buttonElement.textContent = originalText;
          buttonElement.style.background = '#17a2b8';
        }, 3000);
      }
    }

    async function shutdownServer() {
      if (!isEnhancedMode) return;

      const confirmed = confirm('Are you sure you want to stop the server? This will end the setup session.');
      if (!confirmed) return;

      try {
        const response = await fetch('/api/shutdown', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({})
        });

        if (response.ok) {
          // Show shutdown message
          document.body.innerHTML = `
            <div style="display: flex; justify-content: center; align-items: center; height: 100vh; font-family: Arial, sans-serif;">
              <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h2 style="color: #dc3545; margin-bottom: 20px;">ğŸ›‘ Server Stopped</h2>
                <p>The setup server has been shut down successfully.</p>
                <p style="margin-top: 20px; color: #6c757d;">You can close this browser window now.</p>
              </div>
            </div>
          `;
        } else {
          alert('Failed to shutdown server. You may need to stop it manually.');
        }
      } catch (err) {
        console.error('Shutdown request failed:', err);
        alert('Failed to shutdown server. You may need to stop it manually.');
      }
    }

    function getSaveLocationGuide(filename) {
      if (filename === 'AGENTS.md') {
        return 'ğŸ“ your-project/AGENTS.md (project root)';
      } else if (filename === 'GEMINI.md') {
        return 'ğŸ“ your-project/GEMINI.md (project root)';
      } else if (filename === 'CLAUDE.md') {
        return 'ğŸ“ your-project/CLAUDE.md (project root)';
      } else if (filename.endsWith('/AGENTS.md')) {
        return `ğŸ“ your-project/${filename} (rule directory)`;
      } else if (filename.endsWith('/GEMINI.md')) {
        return `ğŸ“ your-project/${filename} (rule directory)`;
      } else if (filename.endsWith('/CLAUDE.md')) {
        return `ğŸ“ your-project/${filename} (rule directory)`;
      } else if (filename.endsWith('/settings.json')) {
        const ruleDir = filename.replace('/settings.json', '');
        return `ğŸ“ your-project/${ruleDir}/settings.json (rule directory)`;
      }
      return `ğŸ“ your-project/${filename}`;
    }

    function showStatusMessage(message, type = 'info') {
      // Create or update status message
      let statusDiv = document.getElementById('status-message');
      if (!statusDiv) {
        statusDiv = document.createElement('div');
        statusDiv.id = 'status-message';
        statusDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 10px 15px;
                    border-radius: 6px;
                    font-weight: bold;
                    z-index: 1000;
                    max-width: 300px;
                `;
        document.body.appendChild(statusDiv);
      }

      statusDiv.textContent = message;
      statusDiv.style.background = type === 'success' ? '#d4edda' : '#fff3cd';
      statusDiv.style.color = type === 'success' ? '#155724' : '#856404';
      statusDiv.style.border = `1px solid ${type === 'success' ? '#c3e6cb' : '#ffeaa7'}`;
      statusDiv.style.display = 'block';

      // Auto-hide after 3 seconds
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 3000);
    }

    // Initialize
    // Config visibility is handled by toggleRule() when rules are selected/deselected


    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }


    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }
  

    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }


    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }


    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }


    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }


    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }


    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }


    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }


    // Per-plugin language selection functions
    function generateLanguageSection(pluginName, availableLanguages) {
      const section = document.createElement('div');
      section.className = 'section';
      section.id = `${pluginName}-language-config`;

      // Get current plugin language preference
      const currentPluginLang = selectedRules[pluginName]?.language || agentLanguage;

      // Get plugin display name
      const pluginData = pluginConfig.plugins[pluginName];
      const pluginLocalization = pluginData.localization || {};
      let displayName = pluginName;
      for (const [lang, data] of Object.entries(pluginLocalization)) {
        if (data.plugin_name) {
          displayName = data.plugin_name;
          break;
        }
      }

      let content = `<h2>${getPluginIcon(pluginName)} ${displayName} - Language Selection</h2>`;
      content += `<p>Choose the language for ${displayName} templates and documentation.</p>`;

      content += `<div class="form-group">`;
      content += `<label for="${pluginName}-language">Plugin Language:</label>`;
      content += `<select id="${pluginName}-language" onchange="updatePluginLanguage('${pluginName}', this.value)">`;

      // Generate options for available languages
      for (const lang of availableLanguages) {
        const isSelected = lang === currentPluginLang;
        let displayText = lang.toUpperCase();

        // Try to get localized name
        const langTable = {
          'en': 'ğŸ‡ºğŸ‡¸ English',
          'ja': 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª',
          'id': 'ğŸ‡®ğŸ‡© Bahasa Indonesia',
          'jv': 'ğŸ‡®ğŸ‡© Basa Jawa',
          'de': 'ğŸ‡©ğŸ‡ª Deutsch',
          'fr': 'ğŸ‡«ğŸ‡· FranÃ§ais',
          'es': 'ğŸ‡ªğŸ‡¸ EspaÃ±ol',
          'ar': 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
          'ko': 'ğŸ‡°ğŸ‡· í•œêµ­ì–´',
          'hi': 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€',
          'pt': 'ğŸ‡µğŸ‡¹ PortuguÃªs',
          'ru': 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹',
          'si': 'ğŸ‡±ğŸ‡° à·ƒà·’à¶‚à·„à¶½',
          'ta': 'ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯',
          'th': 'ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢',
          'tr': 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e',
          'vi': 'ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t',
          'zh': 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡'
        };

        if (langTable[lang]) {
          displayText = langTable[lang];
        }

        content += `<option value="${lang}" ${isSelected ? 'selected' : ''}>${displayText}</option>`;
      }

      content += `</select>`;
      content += `<div class="help-text">Language for ${displayName} rule files and documentation</div>`;
      content += `</div>`;

      section.innerHTML = content;
      return section;
    }

    function updatePluginLanguage(pluginName, language) {
      // Initialize plugin config if it doesn't exist
      if (!selectedRules[pluginName]) {
        selectedRules[pluginName] = {};
      }
      if (typeof selectedRules[pluginName] !== 'object') {
        selectedRules[pluginName] = {};
      }

      // Store the language preference
      selectedRules[pluginName].language = language;

      // Save preferences
      savePreferences();
    }
</script>
</body>

</html>