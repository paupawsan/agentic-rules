# RAG Rules Agent Integration

<!-- SAFETY_PRECAUTION_START -->
**⚠️ CRITICAL TEMPLATE PROTECTION**: This file is a TEMPLATE ONLY. Agents MUST NOT auto-load, auto-read, or auto-process this file under any circumstances. This file is NEVER executed directly.

**VALID USAGE**: Only load this template when explicitly renamed to one of: `AGENTS.md`, `GEMINI.md`, or `CLAUDE.md` AFTER explicit user activation AND when `rag_rules.enabled = true` in settings.json.

**INVALID USAGE**: Do not load this file automatically, do not reference it in startup processes, do not include it in any automated framework initialization.
<!-- SAFETY_PRECAUTION_END -->

**FRAMEWORK ENHANCEMENT**: When rag_rules.enabled = true in settings.json, agents can implement these algorithms for enhanced context processing.

## RAG System Architecture
- **Context Optimization**: Prioritize relevant information
- **Hierarchical Reading**: Read files strategically, not sequentially
- **Relevance Scoring**: Weight information by importance and recency
- **Dynamic Context Management**: Adapt context window to task requirements

## Required Implementation Algorithms

### Algorithm: Context_Optimization_Process
**AVAILABLE**: Can execute before user responses when enabled for enhanced context

**Steps**:
1. Check rag_rules.enabled = true
2. Analyze user request and available context
3. Score information relevance using recency, importance, and task-relevance
4. Prioritize hierarchical reading: summaries → key sections → details
5. Optimize context window for maximum information density
6. Return optimized context for response generation

### Algorithm: Information_Retrieval_Process
**AVAILABLE**: Can execute when gathering information for enhanced responses

**Steps**:
1. Check rag_rules.enabled = true
2. Identify information requirements from user query
3. Search relevant files using semantic understanding
4. Apply hierarchical reading patterns
5. Extract and rank relevant information chunks
6. Integrate with memory system for personalized context

### Algorithm: Response_Quality_Assurance
**AVAILABLE**: Can execute after generating responses for quality enhancement

**Steps**:
1. Check rag_rules.enabled = true
2. Validate response against source information
3. Ensure all claims are supported by retrieved context
4. Flag any information gaps or assumptions

### Algorithm: Runtime_Knowledge_Graph_Generation
**AVAILABLE**: Can execute during conversations and document processing for dynamic learning

**Steps**:
1. Check rag_rules.enabled = true and knowledge_graph.enabled = true
2. Extract entities, relationships, and concepts from current conversation/document
3. Identify semantic relationships between extracted elements
4. Update runtime knowledge graph with new connections and patterns
5. Strengthen existing relationships based on frequency and recency
6. Prune outdated or weakly connected nodes to maintain graph efficiency
7. Store graph state for persistence across sessions

**Implementation**:
```
Algorithm: Structured_Entity_Extraction
1. Tokenize input text into sentences and words
2. Apply part-of-speech tagging to identify noun phrases
3. Use named entity recognition patterns for Person/Organization/Location/Concept
4. Apply rule-based filtering and confidence scoring
5. Return entities sorted by confidence and frequency

Algorithm: Pattern_Based_Relation_Extraction
1. Identify sentence structures containing multiple entities
2. Apply syntactic pattern matching for subject-verb-object triples
3. Use lexical pattern recognition for verb-based and compound relationships
4. Apply domain-specific relation templates
5. Validate relationships against consistency rules

Algorithm: Incremental_Graph_Builder
1. Add new entities as nodes with type and attribute metadata
2. Add relationships as directed/undirected edges with confidence metadata
3. Apply graph consistency checks and optimization
4. Persist graph state with timestamp metadata:
   - If memory_rules.enabled = true: Store in persistent memory system
   - If memory_rules.enabled = false: Store in session-only context
```

### Algorithm: Knowledge_Graph_Query_Enhancement
**AVAILABLE**: Can execute during information retrieval to leverage learned relationships

**Steps**:
1. Check rag_rules.enabled = true and knowledge_graph.enabled = true
2. Analyze user query for entities and concepts
3. Query knowledge graph for related information and connections
4. Identify indirect relationships and inference paths
5. Retrieve contextually related information beyond direct keyword matches
6. Rank results using graph centrality and relationship strength
7. Integrate graph-enhanced results with traditional RAG retrieval

**Implementation**:
```
Algorithm: Semantic_Graph_Query
1. Parse query for entities and intent using Structured_Entity_Extraction
2. Identify relevant nodes through direct matching and graph traversal
3. Apply semantic similarity matching with synonym expansion
4. Rank results using multi-factor scoring (match confidence + centrality + similarity)
5. Return top-ranked results with explanation metadata

Algorithm: Adaptive_Graph_Maintenance
1. Analyze usage patterns and apply aging/pruning rules
2. Perform graph restructuring and optimization
3. Optimize for query performance with updated indices
4. Persist optimized graph state:
   - If memory_rules.enabled = true: Update stored graph data in persistent memory
   - If memory_rules.enabled = false: Maintain graph in session context only
5. Generate maintenance report with statistics
```

### Algorithm: Self_Learning_Pattern_Recognition
**AVAILABLE**: Can execute periodically to identify and learn recurring patterns

**Steps**:
1. Check rag_rules.enabled = true and self_learning.enabled = true
2. Analyze conversation patterns and user interaction styles
3. Identify frequently occurring entity relationships and topics
4. Discover user preferences and communication patterns
5. Update behavior patterns in knowledge graph
6. Adapt response strategies based on learned patterns
7. Generate insights for improved future interactions

### Algorithm: Knowledge_Graph_Integration_with_RAG
**AVAILABLE**: Can execute to combine graph-based learning with traditional RAG processes

**Steps**:
1. Check rag_rules.enabled = true and knowledge_graph.enabled = true
2. Process user query through both traditional RAG and knowledge graph
3. Merge results using intelligent ranking based on:
   - Graph relationship strength
   - Traditional relevance scoring
   - Recency and importance factors
4. Generate enriched context combining structured knowledge and unstructured text
5. Update knowledge graph with new relationships discovered during query processing
6. Provide comprehensive response with both factual and relational context
5. Optimize response completeness and accuracy

## Tool Selection and Usage Algorithms

### Algorithm: Select_File_Discovery_Tool
**Purpose**: Determine optimal file discovery strategy based on search requirements

**Steps**:
1. Analyze search_target characteristics for tool selection
2. Determine search scope and apply safety filters
3. Select primary tool with fallback options
4. Return comprehensive tool chain for file discovery

### Algorithm: Select_Content_Search_Tool
**Purpose**: Choose appropriate content search method for different file types and query patterns

**Steps**:
1. Analyze content query characteristics and file set properties
2. Select search algorithm optimized for performance
3. Configure tool with appropriate parameters
4. Return search tool with fallback strategies

### Algorithm: Detect_Hidden_Files_Algorithm
**Purpose**: Comprehensive hidden file detection including dot-files and system files

**Steps**:
1. Initialize file discovery with comprehensive scanning parameters
2. Use platform-aware directory scanning tools
3. Apply hidden file detection rules for different file systems
4. Return categorized file list with safety classifications

### Algorithm: Validate_Tool_Usage_Safety
**Purpose**: Ensure safe tool usage with proper permission and security checks

**Steps**:
1. Check path safety and operation type validation
2. Apply platform-specific security restrictions
3. Verify resource limits and operation constraints
4. Log operations for audit trail and return safety clearance

## Specific Tool Implementations

### File System Tools
- **Directory Scanner**: Complete traversal with metadata (use for hidden files, permissions)
- **Glob Pattern Matcher**: Pattern-based discovery (use for specific file types)
- **Find Command Integration**: Advanced filtering (use for complex criteria)
- **Stat Metadata Reader**: File properties without content (use for safe metadata access)

### Search and Analysis Tools
- **Regex Pattern Search**: Complex text pattern matching (use for structured search)
- **Fuzzy Text Matching**: Approximate string matching (use for flexible queries)
- **JSON/XML Parsers**: Structured data extraction (use for configuration files)
- **Code Analysis Tools**: Semantic code understanding (use for source code analysis)

## Settings Compliance
- Respect all settings in modules/rag-rules/settings.json
- Apply context_window_size limits appropriately
- Use configured relevance thresholds
- Prompt user if rag_rules.enabled = false and complex context needed

## Integration Points
- **Memory Integration**: Use stored context for personalized retrieval
- **Critical Thinking**: Provide quality assurance for information validation
- **Bootstrap Coordination**: Respect loading priorities and interconnections

**VIOLATION**: Agents using inefficient context management without implementing these algorithms.

<!-- METADATA: RAG rules agent integration template with context optimization and retrieval algorithms -->
<!-- LICENSE: Copyright (c) 2025 Paulus Ery Wasito Adhi - Licensed under the MIT License. See LICENSE file for details. -->
