# 🧠 メモリールールプラグイン (日本語)

## 概要

**メモリールール**プラグインは、AIエージェントに**ローカルの永続的なメモリ**機能を付与し、会話から学び、時間とともに知識を構築できるようにします。このプラグインは、複数のカテゴリを持つ高度なメモリシステムを実装します。

## 📖 このプロジェクトの背景

これは、既存のAIエージェントガイダンスフォーマットの実際的な拡張です。それはハイテクではありません—実世界のニーズから生まれた実用的な解決策です。

**注**: AIエージェントガイダンスフォーマットは、AIエージェントがプロジェクトで効果的に作業するのを助けるための文脈と指示を提供します。人間の開発者をガイドするREADMEファイルに似ています。

### なぜこれが存在するのか

私は多くのメモリツールを使用しました—including memory MCP servers。それらは高速で効率的ですが、根本的な問題があります：**保存されるデータがあまりにも最小限で、適切なデータ抽出なしでは人間の目で直接見ることができません。**

そこで、この**ローカルメモリシステム**を作成することに決めました—シンプルで人間が読めるアプローチで、AIエージェントのメモリに対する完全な可視性と制御を提供します。

### これがあなたを助けること

📊 **毎日の分析**: エージェントがあなたの毎日の発見、障害、苦労、弱点をローカルで分析するのを助ける
📝 **毎日のレポート**: 作業セッションから自動的に毎日のレポートを生成
🔍 **コードベース分析**: コードベースを一度分析してメモリに保存すると、エージェントはブランチ変更や大きなリファクタリング時に適切に更新します—すべてを再分析する必要はありません

### ⚠️ 重要な免責事項

#### プライバシーに関する考慮事項
プライバシーを気にするなら、まずプライバシーに関する機密コンテンツを入力しないでください。

データがローカルで安全に保存されているとしても、使用しているエージェントはプライベートではありません。設定によって、エージェントがあなたが入力したプロンプトから収集したり学習したりすることを防げるかどうかに依存します。

安全な方法：ローカルモデルをローカルサービスで使用：

Ollama
llama.cpp
LM Studio

#### システムの制限
- このシステムはベストエフォートでのテンプレートです—可能な限り汎用的にキュレートされています
- **あなたがアクティブである必要がある**: 何かをさせるためにエージェントに聞くのはあなたです
- **自分で拡張する**: あなたの好みに基づいて、システムを自分で拡張する必要があります
- 独自のルールと好みを作成する際は、高品質モデルを最高の結果のために使用：
  Gemini 3 Pro (Thinking)
  Cursor Composer 1
  GPT-5.1 (Thinking)

## 🎯 機能

**メモリールール**は、単なるチャット履歴を超えた構造化メモリシステムを作成します：

- **永続ストレージ**: セッション間で情報が維持
- **インテリジェント組織化**: 関連情報を自動的に分類とリンク
- **コンテキスト認識**: ユーザー設定、パターン、重要な詳細を記憶
- **セッション間学習**: 複数の相互作用から時間とともに知識を構築

## ✨ 主な機能

### メモリカテゴリ

#### 1. 🧠 **技術メモリ**
- コードパターンとプログラミング知識
- 技術的解決策とトラブルシューティング手順
- ツール使用パターンと設定
- 開発ワークフローとベストプラクティス

#### 2. 🎭 **行動メモリ**
- ユーザー相互作用パターンと設定
- コミュニケーションスタイルと期待
- 応答設定とフィードバックパターン
- パーソナリティ特性と相互作用履歴

#### 3. 📍 **状況別メモリ**
- プロジェクト固有の情報と制約
- 環境詳細と構成
- 現在の作業コンテキストと目的
- セッション固有の要件

#### 4. 💬 **ユーザー相互作用メモリ**
- 重要なユーザーリクエストと要件
- 提供されたフィードバックと修正
- 会話中に表現された設定
- 以前のセッションからの歴史的コンテキスト

#### 5. 📊 **セッションメモリ**
- 会話の流れと進展
- トピックの進化と移行
- 決定ポイントと結果
- セッションの目標と成果

#### 6. 🎯 **トピックメモリ**
- 特定の主題の詳細調査
- 複雑な問題解決セッション
- 研究と分析スレッド
- 長期的な知識開発

#### 7. 📅 **Git履歴メモリ**
- プロジェクトの進化とマイルストーン
- コード変更と開発パターン
- チームコラボレーション履歴
- プロジェクト決定追跡

#### 8. 👤 **個人メモリ**
- 個人設定と作業スタイル
- 個人の目標と動機
- 個人的コンテキストと背景
- 長期的な関係構築

#### 9. 🔐 **認証メモリ**
- APIキー、トークン、アクセス認証情報
- 認証パターンと設定
- セキュリティ関連情報
- アクセス管理設定

#### 10. 🚨 **機密メモリ**
- 機密情報とプライベートデータ
- セキュリティセンシティブな詳細
- プライバシー保護された情報
- 制限されたアクセスコンテンツ

## 🚫 制限と制約

### できないこと
- **リアルタイムコラボレーション**: 複数のエージェントインスタンス間でメモリをリアルタイム同期できない
- **無限ストレージ**: ストレージ構成に基づく実用的制限
- **完全想起**: 最近または頻繁にアクセスされた情報を優先
- **エージェント間共有**: 明示的に構成されていない限り、メモリはエージェント固有
- **自動クリーンアップ**: 手動または構成されたクリーンアップポリシーが必要

### セキュリティ境界
- **ローカルストレージのみ**: メモリは構成されたストレージパス内に留まる
- **ユーザー同意必須**: すべてのメモリ操作に明示的なユーザー許可が必要
- **暗号化可能**: 機密メモリを暗号化可能
- **アクセスコントロール**: 異なるメモリカテゴリに異なるアクセスレベル

## 🎯 使用事例と応用

### 開発ワークフロー強化
```
使用事例: コードレビューヘルパー
メモリがコーディングパターンをキャプチャし、プロジェクトの慣習、ユーザーのコードスタイル設定を記憶
特定のコードスタイル設定を思い出し、一貫したフィードバックを提供
```

### 技術サポートとトラブルシューティング
```
使用事例: システム管理ヘルパー
サーバー構成、一般的な問題、解決パターンを記憶
ユーザーの特定のトラブルシューティング設定と成功した解決策を追跡
システム固有の問題と修正の知識ベースを構築
```

### 研究と分析タスク
```
使用事例: 研究アシスタント
複数のセッションにわたる研究コンテキストを維持
ユーザー関心事、好みの情報源、分析方法を記憶
仮説開発と証拠収集を追跡
```

### クリエイティブコラボレーション
```
使用事例: コンテンツ作成パートナー
執筆スタイル設定と創造的なパターンを記憶
プロジェクトテーマ、キャラクター開発、プロット要素を追跡
創造的なセッション全体で一貫性を維持
```

### 学習と教育
```
使用事例: パーソナライズドチューター
学習スタイルとペースに基づいて適応し、記憶する
進捗、課題、成功したアプローチを記憶
学習セッション全体で継続性を提供
```

## 📝 サンプルプロンプトと使用法

### 基本メモリ活性化
```
"このプロジェクトでTypeScriptをJavaScriptよりも優先し、通常Reactで作業することを覚えておいてください。"
```
→ メモリールールがこの設定を将来のセッションのために保存

### コンテキスト構築
```
"これはNode.jsバックエンドプロジェクトです。Express、MongoDB、JWT認証を覚えておいてください。"
```
→ メモリがプロジェクトコンテキストと技術スタック設定をキャプチャ

### パターン学習
```
"コードレビューの際は、パフォーマンス、セキュリティ、保守性をこの順序で重視してください。"
```
→ メモリがユーザーのコードレビューの優先順位を学習

### セッション継続性
```
"前回のセッションから継続して、認証システムについて..."
```
→ メモリが以前の会話からコンテキストを提供

## ⚡ クイックスタートメモリセットアップ（5分）

ユーザーがメモリをすぐに動作させるための最小限のセットアップ：

### ワンプロンプトセットアップ
```
"このプロジェクトでメモリールールを有効化し、包括的なプロジェクトメモリを構築してください。私は[言語/フレームワーク]アプリケーションを開発しており、[主要技術]を使用しています。私の設定: [2-3つの主要設定]。プロジェクト概要と目標、技術スタック詳細とアーキテクチャ、私のコーディングスタイル設定、一般的なパターンと解決、私のプロジェクト固有の要件と制約を含むメモリを構築してください。MEMORY-RULES.mdで指定されたとおり、メモリストレージプロセスアルゴリズムを正確に実行して、実際のローカルマークダウン(.md)ファイルを適切なディレクトリ構造: [storage.base_path]/projects/[project-id]/[category]/[timestamp]_[category]_memory.mdに作成してください。標準化されたマークダウンテンプレートを使用してください。ファイル作成を確認し、作成された.mdファイルパスの正確なリストを提供してください。"
```
**それだけです！** メモリが有効化され、初期プロジェクトメモリがすぐに構築されます。システムがプロジェクトの詳細と設定を記憶し、今後のすべてのセッションで記憶します。

### クイック検証
**新しいフレッシュなチャットウィンドウを開いて** 尋ねてください：
```
"このプロジェクトについて今まで何を覚えていますか？"
```
→ 基本的なプロジェクト情報と設定を表示する必要があります

### クイックセットアップを使用する場合
- ✅ **メモリ機能に不慣れ** - 複雑さなしに開始
- ✅ **小規模/シンプルなプロジェクト** - 基本メモリで十分
- ✅ **時間制約** - すぐにメモリを動作させる必要
- ✅ **探索的作業** - メモリ機能をすばやくテスト

### 包括的セットアップを使用する場合
- 🔧 **大規模/複雑なプロジェクト** - 詳細なコンテキストとパターンが最大限の効果
- 🔧 **チームコラボレーション** - 複数の開発者で異なる設定
- 🔧 **長期プロジェクト** - 時間とともに最大限のメモリ効果
- 🔧 **カスタムワークフロー** - 特定の要件とエッジケース

### クイックセットアップの利点
- ⚡ **即時有効化** - 1分以内にメモリが動作
- 🎯 **自動学習** - 各相互作用で改善
- 🔄 **段階的強化** - 後で包括的セットアップにアップグレード可能
- 🛡️ **安全なデフォルト** - 保守的な設定で問題を防ぐ

### クイックセットアップのヒント
- **技術スタックを具体的に** - 言語、フレームワーク、データベースを言及
- **2-3つの主要設定を含める** - 最も重要なコーディング/ワークフロー設定に焦点
- **プロジェクトタイプを言及** - "web app"、"API"、"mobile app"、"data analysis"など
- **シンプルに始める** - 各会話でメモリが学習して改善
- **定期的に検証** - "何を覚えているか"と尋ねてメモリの正確性をチェック

### サンプルクイックセットアップ
```
# Web開発
"このプロジェクトでメモリールールを有効化し、包括的なプロジェクトメモリを構築してください。私はReact/TypeScript webアプリケーションをNext.jsとTailwind CSSで開発しています。私の設定: functional components and custom hooks。プロジェクト概要、React/Next.jsアーキテクチャ、TypeScriptパターン、コンポーネント設計設定、Tailwindでのスタイリングアプローチを含むメモリを構築してください。[storage.base_path]/projects/[project-id]/[category]/ディレクトリ構造にマークダウン(.md)ファイルを作成してください。"

# データサイエンス
"このプロジェクトでメモリールールを有効化し、包括的なプロジェクトメモリを構築してください。私はPythonデータ分析プロジェクトでpandas、numpy、matplotlibを使用しています。私の設定: 明確な変数名と包括的なドキュメント。プロジェクト目標、データ分析ワークフロー、Pythonベストプラクティス、視覚化設定、ドキュメント標準を含むメモリを構築してください。[storage.base_path]/projects/[project-id]/[category]/ディレクトリ構造にマークダウン(.md)ファイルを作成してください。"

# バックエンドAPI
"このプロジェクトでメモリールールを有効化し、包括的なプロジェクトメモリを構築してください。私はNode.js/Express APIをMongoDBで構築しています。私の設定: async/await、input validation、comprehensive error handling。APIアーキテクチャ、データベース設計、認証アプローチ、エラーハンドリングパターン、パフォーマンス考慮を含むメモリを構築してください。[storage.base_path]/projects/[project-id]/[category]/ディレクトリ構造にマークダウン(.md)ファイルを作成してください。"
```

---

## 🚀 包括的メモリ強化（高度なセットアップ）

既存のメモリを強化するためのオプションの包括的メモリ強化（最大限の効果）：

### ⚠️ 前提条件
**包括的セットアップを開始する前に、メモリを有効化する必要があります：**

#### オプションA: クイックセットアップ（推奨）
包括的セットアップで強化する前に、上記のワンプロンプトセットアップを使用してメモリをすぐに動作させます。

#### オプションB: 手動有効化
クイックセットアップをスキップしたい場合、まずメモリを手動で有効化：
```
"このプロジェクトでメモリールールを有効化してください。私は[プロジェクトの簡単な説明]で作業しています。"
```
→ これでメモリシステムが有効化され、包括的セットアップが動作します。

#### オプションC: フレームワークセットアップ経由
**メモリ構築は初期化中に有効化されたメモリールールで発生する場合もあります：**

1. **setup.pyを使用:** `python setup.py`を実行し、設定でmemory-rulesを有効化
2. **setup.htmlを使用:** setup.htmlを開き、memory-rulesを設定し、構成ファイルを生成
3. **手動設定:** `memory-rules/settings.json`を編集し、`{"enabled": true}`に設定

→ セットアップシステムを通じて有効化されると、次のエージェント初期化中にメモリが構築されます。構成オプションについてはメインセットアップページを参照してください。

### ステップ1: 初期プロジェクトコンテキストセットアップ
包括的なプロジェクト紹介から始める：

```
これは[プロジェクトタイプ]プロジェクトで、名前は[プロジェクト名]です。主要な詳細を覚えておいてください：

技術スタック:
- 言語: [Python/Node.js/etc.]
- フレームワーク: [Django/React/etc.]
- データベース: [PostgreSQL/MongoDB/etc.]
- デプロイメント: [Docker/AWS/etc.]

チームとワークフロー:
- コードスタイル: [PEP8/ESLint/etc.]
- Gitワークフロー: [GitFlow/trunk-based/etc.]
- テスト: [pytest/Jest/etc.]
- ドキュメント: [Sphinx/JSDoc/etc.]

プロジェクト目標:
- 主要目的: [main purpose]
- ターゲットユーザー: [user type/demographics]
- 主要機能: [main functionality]
- 成功指標: [KPIs/goals]

制約と設定:
- パフォーマンス要件: [response times/etc.]
- セキュリティ要件: [compliance standards]
- 予算/タイムライン: [constraints]
- 私の設定: [your coding style, tools, approaches]
```
→ これですべてのメモリカテゴリにわたる基盤コンテキストを確立

### ステップ2: コードベース親密化
エージェントがコードベースを理解するようにガイド：

```
プロジェクト構造を探索しましょう。これらの主要ディレクトリとその目的を覚えておいてください：

コアディレクトリ:
- src/components: Reactコンポーネント [naming convention]に従う
- src/utils: 共有ユーティリティ、[functional/programming style]を好む
- tests/: [testing framework]を使用したユニットテスト
- docs/: [Markdown/reStructuredText]でのドキュメント

重要なパターン:
- エラーハンドリング: 常に[try/catch/async-await/etc.]を使用
- 状態管理: グローバル状態に[Redux/Context/Zustand/etc.]
- API呼び出し: [Axios/Fetch/etc.] with [error handling pattern]
- ファイル命名: [kebab-case/camelCase/etc.]
```
→ メモリが技術的理解とコーディングパターンを構築

### ステップ3: 個人ワークフローセットアップ
作業設定を確立：

```
私の開発ワークフロー設定を覚えておいてください：

コーディングスタイル:
- インデント: [spaces/tabs] with [width]
- 行長: 最大[80/100/120]文字
- コメント: パブリックAPIに[JSDoc/docstrings/etc.]
- 命名: [descriptive/self-documenting]変数名

レビューの設定:
- 重点領域: [performance > security > maintainability]
- フィードバックスタイル: [constructive/direct/balanced]
- コード例: [always/sometimes/never]例を含む
- 優先順位: [bugs > features > refactoring]

コミュニケーション:
- ステータス更新: [regular/as-needed/on-request]
- 質問形式: [direct/open-ended/structured]
- ドキュメント: [comprehensive/essential/minimal]
```
→ メモリが個人設定と作業スタイルを学習

### ステップ4: 問題-解決パターンビルディング
共通の問題と解決策を確立：

```
このプロジェクトで覚えておくべき一般的な問題：

頻発する問題:
1. データベース接続タイムアウト → 接続プール設定を確認
2. APIレート制限 → 指数バックオフを実装
3. メモリリーク → [tool]でプロファイリングし、[common causes]を修正

解決パターン:
- 認証エラー → トークン形式と有効期限を確認
- 検証失敗 → 入力サニタイズとスキーマを確認
- パフォーマンス問題 → [tool]でプロファイリングし、[bottlenecks]を最適化

デバッグアプローチ:
- [logs/stack traces/error messages]から始める
- [configuration/environment variables]を確認
- [dependencies/versions/compatibility]を検証
- [isolated components/integration points]をテスト
```
→ メモリがトラブルシューティングの知識ベースを構築

### ステップ5: 検証とテスト
メモリセットアップが動作し、ファイルが作成されたことを検証：

```
"プロジェクト情報の主要な詳細を覚えているか、そしてメモリファイルが作成されたかをテストしましょう：

1. 使用しているプログラミング言語とフレームワークは何ですか？
2. 主要ディレクトリとその目的は何ですか？
3. 私のコードレビューの優先順位は何ですか？
4. データベースエラーが発生したら何を最初にチェックしますか？
5. メモリ構築中に作成されたローカルファイルは？ (構成されたストレージディレクトリを確認)

これらを正しく覚えていて、実際のファイルが存在することを確認できれば、メモリセットアップは完了です！"
```
→ メモリ保持と理解を検証

## 🔧 メモリの問題トラブルシューティング

### 症状: セッション間でメモリが永続しない

**可能な原因と解決策:**

1. **ストレージパス問題**
   ```
   症状: 毎回設定がリセットされる
   解決策: メモリストレージパスの権限とディスク容量を確認
   コマンド: 構成されたメモリディレクトリの書き込みアクセスを確認
   ```

2. **設定が保存されない**
   ```
   症状: メモリ設定が保持されない
   解決策: settings.jsonにmemory_rules.enabled = trueがあることを確認
   確認: settings.jsonにメモリ構成が含まれているか
   ```

3. **ブラウザストレージ問題**
   ```
   症状: Webインターフェースがメモリ設定を失う
   解決策: ブラウザキャッシュをクリア、incognitoモードを試す、localStorageを確認
   代替: setup-launcher.pyを使用して永続的なサーバーストレージ
   ```

### 症状: メモリが学習した情報を使用しない

**可能な原因と解決策:**

1. **不十分なコンテキスト**
   ```
   症状: エージェントがプロジェクト詳細を記憶しない
   解決策: より包括的な初期プロジェクトセットアッププロンプトを提供
   追加: 具体例、コードスニペット、詳細な設定
   ```

2. **カテゴリミスマッチ**
   ```
   症状: 情報は保存されているが取得されない
   解決策: メモリカテゴリマッピングを確認
   検証: 技術詳細 → 技術カテゴリ
   個人設定 → 行動/個人カテゴリ
   ```

3. **クエリコンテキスト問題**
   ```
   症状: エージェントに情報があるが適用しない
   解決策: クエリでより明確にする
   試す: "プロジェクトセットアップを思い出して..." または "前回の議論に基づいて..."
   ```

### 症状: メモリ競合や矛盾

**可能な原因と解決策:**

1. **複数プロジェクト混乱**
   ```
   症状: エージェントが異なるプロジェクトから情報を混同
   解決策: プロンプトでプロジェクトコンテキストを明確に指定
   使用: "[プロジェクト名]プロジェクトで..." プレフィックス
   ```

2. **古くなった情報**
   ```
   症状: エージェントがプロジェクト変更後に古いパターンを使用
   解決策: 新しい情報でメモリを明示的に更新
   コマンド: "メモリを更新: [古い]から[新しい]に切り替えた"
   ```

3. **保持ポリシー問題**
   ```
   症状: 重要な情報がクリーンアップされる
   解決策: メモリ構成で保持設定を調整
   増加: 重要なカテゴリのretention_days
   ```

### 症状: メモリのパフォーマンス問題

**可能な原因と解決策:**

1. **メモリサイズが大きすぎる**
   ```
   症状: 応答時間が遅い、高いメモリ使用量
   解決策: settingsでmax_entries_per_categoryを減らす
   有効化: compressionとcleanupポリシー
   ```

2. **頻繁なアクセスパターン**
   ```
   症状: メモリ操作が遅くなる
   解決策: キャッシングを有効化、最適化インデックス
   確認: メモリパフォーマンス設定
   ```

3. **ストレージI/Oボトルネック**
   ```
   症状: メモリ操作が遅延を引き起こす
   解決策: メモリストレージをより高速なストレージメディアに移動
   確認: SSD vs HDD、ローカル vs ネットワークストレージ
   ```

### 症状: メモリが修正から学習しない

**可能な原因と解決策:**

1. **修正形式問題**
   ```
   症状: エージェントが同じ間違いを繰り返す
   解決策: 修正について明確にする
   使用: "将来の参考として覚えておいて: [間違い]は[修正]にするべき"
   ```

2. **フィードバックループ無効**
   ```
   症状: 修正が保持されない
   解決策: メモリ設定でエラー学習を有効化
   確認: error_correction_learning = true
   ```

### 高度なトラブルシューティング

#### メモリ検査
```
メモリに何が入っているかをチェックするために、エージェントに尋ねる:
"このプロジェクトの技術スタックについて何を覚えていますか？"
"コードレビューの私の設定は何ですか？"
"私たちが遭遇した一般的な問題をリストできますか？"
```

#### メモリリセット
```
メモリをリセットする必要がある場合:
1. エージェント/セッションを停止
2. メモリストレージディレクトリを削除
3. フレッシュメモリセットアップで再起動
4. 初期プロジェクトセットアッププロンプトを再実行
```

#### 設定検証
```
メモリ構成を確認:
- settings.jsonが存在し、有効なJSON
- memory_rules.enabled = true
- ストレージパスが書き込み可能
- 保持ポリシーが合理的な範囲
- プロジェクトサイズに適したカテゴリ制限
```

### ヘルプを得る

トラブルシューティングで問題が解決しない場合：

1. **ログを確認**: メモリ関連のエラーメッセージを探す
2. **設定を検証**: すべての設定が正しく設定されていることを確認
3. **分離テスト**: クリーン環境でメモリセットアップを試す
4. **コミュニティサポート**: GitHubの問題で同様の問題を確認
5. **詳細なバグレポート**: 構成、ログ、再現ステップを含める

## ⚙️ 設定オプション

### ストレージ構成
```json
{
  "memory_rules": {
    "enabled": true,
    "max_entries_per_category": 100,
    "retention_days": 90,
    "auto_cleanup": true
  }
}
```

### カテゴリ固有設定
```json
{
  "categories": {
    "technical": {
      "enabled": true,
      "retention_days": 180,
      "priority": "high"
    },
    "personal": {
      "enabled": true,
      "retention_days": 365,
      "encryption": true
    }
  }
}
```

## 🔄 他のルールとの統合

### RAGルールとの相乗効果
- メモリが個人化されたコンテキストを情報検索に提供
- RAGがメモリ検索と関連性スコアリングを最適化
- 組み合わせたシステムがインテリジェントな知識検索を作成

### 批判的思考ルール強化
- メモリがエラー修正と学習洞察を保存
- 批判的思考がメモリの正確性と一貫性を検証
- 検証されたメモリ更新を通じて自己改善システム

### Bootstrap調整
- メモリ初期化がBootstrap読み込み順序に従う
- 他のルールとの共有コンテキストを通じて接続
- システム全体の一貫性と結束を維持

## 📊 パフォーマンスとストレージ

### ストレージ要件
- **ベースメモリ**: 一般的な使用で~10MB
- **拡張使用**: 会話量に応じてスケール
- **圧縮**: 大きなメモリ用の自動圧縮
- **バックアップ**: クリーンアップ操作前に自動バックアップ

### パフォーマンス特性
- **アクセス速度**: 最近のメモリでサブ秒検索
- **検索性能**: すべてのカテゴリ全体で高速全文検索
- **インデックス化**: クイックルックアップのための自動インデックス化
- **クリーンアップ**: クリーンアップがパフォーマンスに影響しない

## 🔧 トラブルシューティング

### メモリが永続しない
```
症状: セッション間で情報が失われる
解決策: ストレージパスの権限と利用可能なディスク容量を確認
```

### 低パフォーマンス
```
症状: メモリ操作に時間がかかりすぎる
解決策: max_entries_per_categoryを減らすか、圧縮を有効化
```

### メモリ競合
```
症状: 不一致または競合する情報
解決策: 保持ポリシーとクリーンアップ頻度を確認
```

## 📚 関連ドキュメント

- **[RULES.md.ja](RULES.md.ja)** - 技術アルゴリズム仕様
- **[settings.json](settings.json)** - 設定オプションリファレンス
- **[../../../../docs/CORE-RULES.ja.md](../../../../docs/CORE-RULES.ja.md)** - フレームワークアーキテクチャ概要
- **[../../../../docs/localization/ja/USER-GUIDE.ja.md](../../../../docs/localization/ja/USER-GUIDE.ja.md)** - 基本セットアップ手順

## 🤝 貢献

メモリ機能に関する問題や提案はありますか？

- **バグレポート**: [GitHub Issues](../../issues)
- **機能リクエスト**: [GitHub Discussions](../../discussions)
- **コード貢献**: メモリ改善のためのプルリクエストを送信

---

**🧠 メモリールール**: AIエージェントに記憶、学習、成長の贈り物。各相互作用で成長。

*Copyright (c) 2025 Paulus Ery Wasito Adhi. MIT Licenseの下でライセンスされています。*