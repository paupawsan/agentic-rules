# エージェントインタラクションユニットテスト モジュール

## 概要

エージェントインタラクションユニットテスト モジュールは、エージェント会話の自動検証・テストフレームワークを提供し、最大限の透明性とグラウンドチェック要件を備えています。このモジュールは、ユニットテストシナリオで簡単に有効化/無効化できます。

## 機能

- **グラウンドチェック検証**: ソースデータに対するすべての情報の自動検証
- **仮定チャレンジ**: 作成されたすべての仮定の識別と検証
- **エラー承認**: ハルシネーションの即時検出と修正
- **ツールコール監査**: 検証付きのすべてのツール実行の完全なログ記録
- **決定プロセス監査**: 代替案を含むすべての決定ポイントの文書化
- **コンテキスト管理監視**: コンテキストウィンドウ利用率と最適化の追跡
- **エージェントデバッグ分析**: エージェントの推論プロセス、ツール使用、パラメータ選択の体系的分析 (CORE-RULES.md で詳細アルゴリズムを参照)
- **コンプライアンス検証**: フレームワーク要件に対する自動チェック

## クイックスタート

1. **モジュールを有効化** して `settings.json` で `"agent_interaction_unit_test.enabled": true` を設定
2. **テストケースを実行** Agentic Rules Framework 標準で
3. **検証レポートを確認** コンプライアンスと正確性メトリクス用
4. **完了したら無効化** `"agent_interaction_unit_test.enabled": false` を設定

## 設定

`modules/agent-interaction-unit-test/settings.json` を編集して設定:

```json
{
  "agent_interaction_unit_test": {
    "enabled": false,  // ユニットテストを有効にするには true に設定
    "validation_level": "standard",
    "ground_check": {
      "enabled": true,
      "required_coverage": 100
    }
    // ... 追加設定
  }
}
```

## テストケース形式

ユニットテストにこの形式を使用:

```markdown
# UNIT TEST: [Test_Name]
**Framework:** Agentic Rules v1.2.0
**Task:** [Specific_Test_Task]

[Execute agent with unit test validation...]
```

### 実績のある効果的な例

このプロンプトパターンは検証済みで効果的であることが証明されています:

```markdown
UNIT TEST: エージェントメモリ検索
Framework: Agentic Rules v1.2.0
Task: 基本的なエージェントメモリ検索をテストします。

Instruction:
現在のプロジェクトのメモリを同期してください。

Output:
このフォルダにマークダウン形式のユニットテストレポートが欲しい [あなたのレポートフォルダ]
```

## 検証基準

モジュールは次の基準に対してレスポンスを検証:
- ✅ **100% フレームワークコンプライアンス** - すべてのアルゴリズムが実行
- ✅ **100% グラウンドチェックカバレッジ** - すべての主張が検証
- ✅ **0% ハルシネーション** - すべての情報がソース検証済み
- ✅ **完全なツール透明性** - すべての呼び出しがログ記録
- ✅ **決定文書化** - すべての選択が説明
- ✅ **エージェントデバッグ分析** - 体系的推論とツール使用検証

## 統合

このモジュールは以下と統合:
- **メモリルール**: テスト結果と検証履歴を保存
- **RAGルール**: テストシナリオ向けにコンテキストを最適化
- **クリティカルシンキングルール**: グラウンドチェック検証サポートを提供

## エージェントデバッグ分析

このモジュールには、`AgentDebuggingAnalysis_Process`アルゴリズムによる高度なデバッグ機能が含まれており、エージェント動作の体系的分析を提供します:

### 主なデバッグ機能
- **Chain of Thoughts分析**: 推論プロセスと意思決定の詳細な調査
- **ツール使用検証**: ツール選択の適切さとパラメータ選択の分析
- **パラメータ最適化**: パラメータ設定とその有効性の評価
- **パフォーマンス評価**: 非効率性の特定と最適化機会
- **構造化レポート**: 包括的なマークダウン形式のデバッグレポート

### デバッグレポート構造
デバッグ分析は以下の構造化レポートを生成:
1. **Chain of Thought**: 完全な生のステップバイステップ推論と意思決定プロセス文書
2. **ステップバイステップ分析**: 各推論ステップ、決定、使用ツール、発見の表形式詳細
3. **主要な問題と改善機会**: 重要な問題と改善提案
4. **推奨事項**: パフォーマンス向上のための実行可能な提案
5. **主要ステップの概要**: 主な発見を強調する3-5つの箇点

### デバッグ使用例
- **コード分析検証**: コード分析と推奨事項の正確性の検証
- **ツール選択レビュー**: ツール選択とパラメータ設定の適切性の評価
- **推論プロセス監査**: 論理的フローと意思決定品質の調査
- **パフォーマンス最適化**: ボトルネックの特定と改善提案

## 使用例

### テスト用に有効化
```json
{
  "agent_interaction_unit_test": {
    "enabled": true
  }
}
```

### テストケースを実行
```
UNIT TEST: Code Analysis Validation
Framework: Agentic Rules v1.2.0
Task: Analyze the function in setup.html that generates AGENTS.md files

[Agent executes with full validation...]
```

### 結果を確認
エージェントは以下を提供:
- フレームワークコンプライアンス監査
- グラウンドチェック検証ログ
- ツールコール監査証跡
- 決定プロセス文書化
- 最終ユニットテストレポート

## 実世界ユースケース: 開発タスク検証

このセクションでは、エージェントインタラクションユニットテストモジュールの特定の開発タスクへの実用的適用を示し、最大限の正確性と透明性を確保します。

### セットアップ開始 (必須の最初のステップ)

**重要:** ユニットテストコンテキストを確立するための開始クエリから始めます:

```
ユーザークエリ: "すべてのインタラクションをユニットテスト用に記録するセットアップ"
```

これにより、エージェントは現在の会話で包括的な検証を準備するよう指示されます。開始されると、同じ会話のすべての後続クエリが自動的にユニットテスト検証を受け取ります。

### ユースケース1: コード分析 & デバッグ
```
UNIT TEST: code_analysis_debugging
Framework: Agentic Rules v1.2.0
Task: Analyze authentication module for security vulnerabilities

ユーザークエリ: "auth.jsの認証コードを潜在的なセキュリティ問題について分析してください"
```

**検証フォーカス:**
- コード分析主張のグラウンドチェック検証
- セキュリティ評価の仮定検証
- 正確なコード読み取りのためのツールコール監査
- 脆弱性優先順位付けのための決定文書化

### ユースケース2: 問題特定
```
UNIT TEST: problem_identification
Framework: Agentic Rules v1.2.0
Task: Identify root cause of database connection failures

ユーザークエリ: "本番環境のデータベース接続問題をデバッグ - ログを確認して根本原因を特定してください"
```

**検証フォーカス:**
- ログ分析主張のソース検証
- エラーパターンの相互参照
- 診断結論の仮定チャレンジ
- 証拠ベースの根本原因特定

### ユースケース3: コードベースアーキテクチャ分析
```
UNIT TEST: architecture_analysis
Framework: Agentic Rules v1.2.0
Task: Analyze codebase structure and recommend improvements

ユーザークエリ: "コードベース全体の構造を分析し、アーキテクチャの改善を提案してください"
```

**検証フォーカス:**
- 包括的なファイル構造検証
- 依存関係分析検証
- アーキテクチャパターン認識の正確性
- 証拠による推奨事項の正当性

### ユースケース4: リファクタリング検証
```
UNIT TEST: refactoring_validation
Framework: Agentic Rules v1.2.0
Task: Validate refactoring changes maintain functionality

ユーザークエリ: "最近のリファクタリング変更を確認して、既存の機能を破壊しないことを確認してください"
```

**検証フォーカス:**
- コード変更影響評価の正確性
- 回帰検出検証
- 互換性検証
- リスク評価文書化

### ユースケース5: 包括的システムテスト
```
UNIT TEST: comprehensive_agent_interaction_testing
Framework: Agentic Rules v1.2.0
Task: Complete interaction validation and compliance testing

ユーザークエリ: "ツールの呼び出しとパラメータを含む詳細なエージェントインタラクションシーケンスログを作成してください"
```

### ユースケース6: エージェントデバッグ分析
```
UNIT TEST: agent_debugging_analysis
Framework: Agentic Rules v1.2.0
Task: Systematic debugging and validation of agent reasoning processes

ユーザークエリ: "以前のコード分析タスクのエージェント推論プロセスをデバッグしてください"
```

**デバッグ分析フォーカス:**
- Chain of thoughtsの調査と論理的フローの検証
- ツール選択の適切さとパラメータ最適化
- 推論プロセスの効率性と決定品質の評価
- パフォーマンスボトルネックの特定と改善推奨

### 詳細なインタラクション例

**例: コード分析検証中**

ユーザーがコード分析を要求すると、ユニットテストフレームワークは包括的な詳細をキャプチャします:

#### ツールコール監査ログ
```
🔍 ツールコール #1: run_terminal_cmd
├── 関数: run_terminal_cmd
├── パラメータ: {"command": "find /project -name '*.js' -type f | head -10", "is_background": false}
├── 実行時間: 0.245 秒
├── 関連性スコア: 95% (正当性: コードベース発見に不可欠)
├── 結果: プロジェクトルートに8つのJavaScriptファイルが見つかりました

🔍 ツールコール #2: read_file
├── 関数: read_file
├── パラメータ: {"target_file": "auth.js", "offset": 1, "limit": 50}
├── 実行時間: 0.089 秒
├── 関連性スコア: 98% (正当性: ユーザー要求への直接応答)
├── 結果: 認証モジュールの読み取りに成功 (50行)

🔍 ツールコール #3: grep
├── 関数: grep
├── パラメータ: {"pattern": "password|secret|key", "path": "auth.js", "output_mode": "content", "case_insensitive": true}
├── 実行時間: 0.156 秒
├── 関連性スコア: 97% (正当性: セキュリティ分析要件)
├── 結果: 3つの潜在的なセキュリティパターンが見つかりました
```

#### 決定監査証跡
```
🎯 決定ポイント: セキュリティ分析アプローチ
├── 検討されたオプション:
│   ├── オプション1: 表面レベルのパターンマッチングのみ
│   ├── オプション2: コンテキスト付きの深いコード分析
│   ├── オプション3: ブラックボックスのセキュリティテスト
├── 選択: オプション2 (コンテキスト付きの深いコード分析)
├── 根拠: 包括的なセキュリティ検証を提供
├── リスク評価: 処理時間よりも高い正確性が優先
├── 検証: グラウンドトゥルース - 業界セキュリティベストプラクティス
├── 結果: 深い分析アプローチが選択されました
```

#### コンテキスト管理メトリクス
```
📊 コンテキストウィンドウ利用率: 78%
├── アクセスされたメモリカテゴリ: 4
│   ├── 技術メモリ: 3エントリが参照されました
│   ├── 行動メモリ: 2エントリが参照されました
│   ├── コンテキストメモリ: 1エントリが参照されました
│   ├── セッションメモリ: 現在のセッショントラッキング
├── 情報優先順位付け: セキュリティクリティカルなパターンが優先されました
├── メモリ統合: 5つの相互参照が確立されました
├── 最適化アクション: コンテキスト圧縮が適用されました (15%削減)
```

#### グラウンドチェック検証結果
```
✅ グラウンドチェック #1: ファイル存在
├── 主張: "auth.js がプロジェクトに存在する"
├── 検証: ファイルシステムスキャンで確認
├── ソース: run_terminal_cmd の結果
├── ステータス: 検証済み

✅ グラウンドチェック #2: コード内容の正確性
├── 主張: "ファイルに認証ロジックが含まれる"
├── 検証: パターン分析で12のauth関連関数を確認
├── ソース: grep と read_file の結果
├── ステータス: 検証済み

✅ グラウンドチェック #3: セキュリティ発見の検証
├── 主張: "潜在的なSQLインジェクション脆弱性"
├── 検証: OWASPガイドラインに対して相互参照
├── ソース: 複数のセキュリティパターンデータベース
├── ステータス: 検証済み
```

### 検証付き実行フロー

#### 1. 初期化フェーズ
- **アルゴリズム**: AgentInteractionUnitTestValidation_Initialization_Process
- **検証**: 設定が検証され、フレームワークがアクティブ化
- **結果**: ユニットテストセッションメモリが作成

#### 2. グラウンドチェック検証
- **アルゴリズム**: GroundCheckValidation_Process
- **検証**: すべての情報主張がソースに対して検証
- **結果**: すべてのステートメントで100%正確性が確認

#### 3. 仮定チャレンジ
- **アルゴリズム**: AssumptionChallenge_Process
- **検証**: レスポンス仮定が特定されチャレンジ
- **結果**: すべての仮定が証拠で検証

#### 4. ツールコール監査
- **アルゴリズム**: ToolCallAudit_Process
- **検証**: パラメータと結果を含むすべてのツールコールがログ
- **結果**: 関連性スコア付きの完全な監査証跡

#### 5. 決定プロセス監査
- **アルゴリズム**: DecisionAudit_Process
- **検証**: 代替案を含むすべての決定ポイントが文書化
- **結果**: 意思決定における完全な透明性

#### 6. コンテキスト管理
- **アルゴリズム**: ContextManagementAudit_Process
- **検証**: コンテキスト利用が監視され最適化
- **結果**: 効率的なコンテキスト管理が確認

#### 7. コンプライアンス検証
- **アルゴリズム**: AgentInteractionUnitTestCompliance_Process
- **検証**: 100%フレームワークコンプライアンスが検証
- **結果**: ✅ 合格 - 完全な検証が達成

### テスト結果サマリー
```
✅ フレームワークコンプライアンス: 100%
✅ グラウンドチェックカバレッジ: 100%
✅ ハルシネーション検出: 0%
✅ ツール透明性: 完全
✅ 決定文書化: 完全な監査証跡
✅ エージェントデバッグ分析: 包括的な推論検証
```

### メモリシステムへの影響
ユニットテストセッションにより:
- **8つのメモリファイル**が作成 (7コンテンツ + 1インデックス)
- **40KBストレージ**が使用
- **100%検証カバレッジ**が維持
- **完全な監査証跡**が保存

### 主な学び
1. **フレームワークの堅牢性**: すべてのアルゴリズムが正常に実行
2. **メモリ統合**: 既存のメモリシステムとのシームレスな統合
3. **透明性の利点**: すべての操作に対する完全な可視性
4. **検証の有効性**: グラウンドチェック検証で100%正確性が達成

### レプリケーション手順
開発タスクにユニットテストを適用するには:

1. ユニットテストを有効化: settings.json で `"agent_interaction_unit_test.enabled": true` を設定
2. **ユニットテストコンテキストを開始** (会話の最初のクエリ):
   - クエリ: `"setup to record all interaction for unit test"`
   - これにより、会話全体で包括的な検証が確立されます
3. **開発タスクを実行** (後続のクエリは自動的に検証されます):
   - **コード分析**: `"auth.jsの認証コードをセキュリティ問題について分析してください"`
   - **デバッグ**: `"データベース接続問題をデバッグして根本原因を特定してください"`
   - **アーキテクチャレビュー**: `"コードベース構造を分析し、改善を提案してください"`
   - **リファクタリング**: `"リファクタリング変更を確認して既存の機能を破壊しないことを確認してください"`
4. 検証レポートを確認: フレームワークコンプライアンス、グラウンドチェックカバレッジ、決定文書化をチェック
5. メトリクスを分析: 正確性スコア、仮定検証、ツールコール透明性を評価
6. 完了したら無効化: `"agent_interaction_unit_test.enabled": false` を設定

## 安全対策

- **テンプレート保護**: AGENTS.md はテンプレート専用としてマーク
- **ユーザー同意**: 設定での明示的な有効化が必要
- **フレームワーク分離**: ユーザーprojectコードベースに含まれることは決してない
- **エラー透明性**: すべての失敗が即時報告され修正される

## 貢献

標準の Agentic Rules Framework 貢献ガイドラインに従ってください。すべての変更はフレームワークコンプライアンスとグラウンドチェック検証要件を維持する必要があります。

---

**フレームワーク統合:** Agentic Rules v1.2.0+ と互換性あり
**ライセンス:** MIT License
**メンテナンス:** アクティブにメンテナンス
